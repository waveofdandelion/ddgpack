{"version":3,"sources":["../src/core.ts","../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/modules/Logger.ts","../src/defs/hooks.ts","../../../node_modules/path-to-regexp/index.js","../src/schemas/attribute.ts","../src/utils/dom.ts","../src/utils/history.ts","../src/utils/helpers.ts","../src/utils/url.ts","../src/utils/request.ts","../../../node_modules/is-promise/index.js","../src/utils/run-async.ts","../src/hooks.ts","../src/modules/Ignore.ts","../src/modules/Cache.ts","../src/modules/Prevent.ts","../src/modules/Error.ts","../src/modules/Store.ts","../src/modules/Transitions.ts","../src/modules/Views.ts","../src/polyfills/index.ts","../src/schemas/page.ts","../src/css.ts"],"names":["_wrapper","_catch","body","recover","result","e","then","Symbol","iterator","asyncIterator","LogLevels","HookMethods","_level","off","Logger","source","this","_source","getLevel","setLevel","name","error","objects","_log","console","warn","warning","info","debug","log","fn","level","apply","concat","pathToRegexp","regexpToFunction","parse","tokensToFunction","tokensToRegExp","DEFAULT_DELIMITER","PATH_REGEXP","RegExp","join","str","options","res","tokens","key","index","path","defaultDelimiter","delimiter","whitelist","undefined","pathEscaped","exec","m","escaped","offset","slice","length","prev","capture","group","modifier","k","c","indexOf","push","pattern","prefix","optional","repeat","escapeGroup","escapeString","substr","re","keys","pathname","params","decode","decodeURIComponent","i","split","map","value","matches","Array","flags","data","encode","encodeURIComponent","validate","token","segment","isArray","TypeError","j","test","String","replace","sensitive","strict","start","end","endsWith","route","endToken","isEndDelimited","groups","match","parts","schemaAttribute","container","history","namespace","prevent","wrapper","dom","DOMParser","toString","el","outerHTML","toDocument","htmlString","_parser","parseFromString","toElement","div","document","createElement","innerHTML","getHtml","doc","documentElement","getWrapper","scope","querySelector","_attr","getContainer","removeContainer","contains","parentNode","removeChild","addContainer","existingContainer","_insertAfter","appendChild","getNamespace","ns","getAttribute","getHref","tagName","toLowerCase","href","resolveUrl","baseVal","urls","numUrls","Error","base","arguments","head","getElementsByTagName","insertBefore","firstChild","resolved","a","newNode","referenceNode","nextSibling","init","url","_session","state","scroll","x","window","scrollX","y","scrollY","_states","_pointer","item","from","states","replaceState","change","trigger","_getDirection","add","size","action","_getAction","pushState","update","get","set","remove","splice","pop","clear","newStates","attr","hasAttribute","diff","Math","abs","page","next","html","nextDocument","title","ptr","Promise","resolve","requestAnimationFrame","getOrigin","location","origin","getPort","port","portString","substring","parseInt","hash","query","hashIndex","queryIndex","parseQuery","reduce","acc","clean","request","ttl","requestError","reject","xhr","XMLHttpRequest","onreadystatechange","readyState","DONE","status","responseText","statusText","ontimeout","err","onerror","open","timeout","setRequestHeader","send","obj","runAsync","func","ctx","args","async","answer","isPromise","hooks","_this","Map","registered","all","forEach","hook","_this2","has","Set","chain","_this3","logger","_this4","help","Ignore","ignore","_ignoreAll","paths","_ignoreRegexes","p","checkHref","some","regex","Cache","_state","getRequest","getAction","exists","newTab","event","which","metaKey","ctrlKey","shiftKey","altKey","blank","target","corsDomain","protocol","hostname","corsPort","download","preventSelf","preventAll","Boolean","closest","sameUrl","Prevent","check","suite","tests","run","checkLink","BarbaError","label","captureStackTrace","Store","transitions","type","_rules","position","filters","once","filter","self","t","matching","active","find","valid","reverse","rule","_check","to","activeMatch","transitionType","infos","Object","_addPriority","sort","b","priority","leave","enter","transition","direction","isValid","hasMatch","strRule","objRule","fnName","current","names","_calculatePriority","ruleName","ruleIndex","pow","Transitions","store","doOnce","_running","_doAsyncHook","doPage","sync","_isTransitionError","leaveResult","helpers","values","message","Views","views","view","byNamespace","_createHook","Element","prototype","msMatchesSelector","webkitMatchesSelector","s","parentElement","nodeType","schemaPage","version","use","plugin","installedPlugins","plugins","install","schema","cacheIgnore","prefetchIgnore","preventRunning","preventCustom","logLevel","_requestCustomError","setAttribute","_resetData","cache","_onLinkEnter","bind","_onLinkClick","_onStateChange","_bind","onceData","destroy","_unbind","force","assign","go","isRunning","getPath","hasSelf","stopPropagation","preventDefault","readyData","hasOnce","onRequestError","shouldWait","response","prefetch","_this5","addEventListener","removeEventListener","link","_getLinkElement","_this6","_data","barba","_once","_leave","_enter","before","_getPrefix","beforeOnce","_beforeOnce","afterOnce","_afterOnce","beforeLeave","_beforeLeave","afterLeave","_afterLeave","beforeEnter","_beforeEnter","afterEnter","_afterEnter","unshift","kind","nextTick","_hasTransition","_checkTransition","cb","callbacks","step","classList","getComputedStyle","transitionDuration","_this8","_this10","_this12"],"mappings":";;AAgQgBA,IAAAA,GC5BhB,SAAA,EAAA,GAAA,iBAAA,SAAA,oBAAA,OAAA,OAAA,QAAA,IAAA,mBAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,MAAA,MAAA,IAAA,CAAA,KAAA,WAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,SAAA,IAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,CAAA,IAAA,EAAA,UAAA,GAAA,IAAA,IAAA,KAAA,EAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,WAAA,SAAA,EAAA,EAAA,GAAA,EAAA,UAAA,OAAA,OAAA,EAAA,WAAA,EAAA,UAAA,YAAA,EAAA,EAAA,UAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,eAAA,OAAA,eAAA,SAAA,GAAA,OAAA,EAAA,WAAA,OAAA,eAAA,KAAA,GAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,SAAA,EAAA,GAAA,OAAA,EAAA,UAAA,EAAA,IAAA,EAAA,GAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,WAAA,GAAA,oBAAA,UAAA,QAAA,UAAA,OAAA,EAAA,GAAA,QAAA,UAAA,KAAA,OAAA,EAAA,GAAA,mBAAA,MAAA,OAAA,EAAA,IAAA,OAAA,KAAA,UAAA,SAAA,KAAA,QAAA,UAAA,KAAA,GAAA,gBAAA,EAAA,MAAA,GAAA,OAAA,GAAA,GAAA,QAAA,UAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,CAAA,MAAA,EAAA,KAAA,MAAA,EAAA,GAAA,IAAA,EAAA,IAAA,SAAA,KAAA,MAAA,EAAA,IAAA,OAAA,GAAA,EAAA,EAAA,EAAA,WAAA,IAAA,MAAA,KAAA,WAAA,SAAA,EAAA,GAAA,IAAA,EAAA,mBAAA,IAAA,IAAA,SAAA,EAAA,OAAA,EAAA,SAAA,GAAA,GAAA,OAAA,IAAA,IAAA,SAAA,SAAA,KAAA,GAAA,QAAA,iBAAA,OAAA,EAAA,GAAA,mBAAA,EAAA,MAAA,IAAA,UAAA,sDAAA,QAAA,IAAA,EAAA,CAAA,GAAA,EAAA,IAAA,GAAA,OAAA,EAAA,IAAA,GAAA,EAAA,IAAA,EAAA,GAAA,SAAA,IAAA,OAAA,EAAA,EAAA,UAAA,EAAA,MAAA,aAAA,OAAA,EAAA,UAAA,OAAA,OAAA,EAAA,UAAA,CAAA,YAAA,CAAA,MAAA,EAAA,YAAA,EAAA,UAAA,EAAA,cAAA,KAAA,EAAA,EAAA,KAAA,GAAA,SA8UgBC,EAAOC,EAAMC,GAC5B,IACC,IAAIC,EAASF,IACZ,MAAMG,GACP,OAAOF,EAAQE,GAEhB,OAAID,GAAUA,EAAOE,KACbF,EAAOE,UAAK,EAAQH,GAErBC,EAvZuD,oBAAXG,SAA0BA,OAAOC,WAAaD,OAAOC,SAAWD,OAAO,qBA6DvD,oBAAXA,SAA0BA,OAAOE,gBAAkBF,OAAOE,cAAgBF,OAAO,0BC3M9HG,IAAAA,ECmBCC,EAAAA,SDnBb,SAAYD,GACVA,EACAA,EAAAA,IAAAA,GAAAA,MAAAA,EACAA,EAAAA,MAAAA,GAAAA,QAAAA,EACAA,EAAAA,QAAAA,GAAAA,UAAAA,EACAA,EAAAA,KAAAA,GAAAA,OAAAA,EALF,EAAA,MAAA,GAAA,QAAA,CAAYA,IAAAA,EAWZ,KAAA,IAAIE,EAAiBF,EAAUG,IAElBC,EAyBX,WAAA,SAAYC,EAAAA,GACVC,KAAKC,EAAUF,EA1BnBD,EAIgBI,SAAP,WACL,OAAON,GAMKO,EAAAA,SAAP,SAAgBC,GAGrB,OAFAR,EAASF,EAAUU,IA2BdC,IAAAA,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,MAAA,WAASC,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EACdN,GAAAA,UAAAA,GAAAA,KAAKO,EAAKC,QAAQH,MAAOX,EAAUW,MAAOC,IAMrCG,EAAAA,KAAA,WAAQH,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EACbN,GAAAA,UAAAA,GAAAA,KAAKO,EAAKC,QAAQC,KAAMf,EAAUgB,QAASJ,IAMtCK,EAAAA,KAAA,WAAQL,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EACbN,GAAAA,UAAAA,GAAAA,KAAKO,EAAKC,QAAQG,KAAMjB,EAAUiB,KAAML,IAMnCM,EAAAA,MAAA,WAASN,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EACdN,GAAAA,UAAAA,GAAAA,KAAKO,EAAKC,QAAQK,IAAKnB,EAAUkB,MAAON,IAMlCC,EAAAA,EAAA,SAAKO,EAAgBC,EAAeT,GACtCS,GAASjB,EAAOI,YAClBY,EAAGE,MAAMR,QAAU,CAAKR,IAAAA,KAAKC,EAAagB,MAAAA,OAAOX,KErGtCY,EFyDf,GEzDeA,EAAAA,EAEiBC,EAAAA,EACXC,EAAAA,EAEWC,EAAAA,EACFC,EAAAA,EAK5BC,EAAoB,IAOpBC,EAAc,IAAIC,OAAO,CAG3B,UAMA,uFACAC,KAAK,KAAM,KASb,SAASN,EAAOO,EAAKC,GAUnB,IATA,IAOIC,EAPAC,EAAS,GACTC,EAAM,EACNC,EAAQ,EACRC,EAAO,GACPC,EAAoBN,GAAWA,EAAQO,WAAcZ,EACrDa,EAAaR,GAAWA,EAAQQ,gBAAcC,EAC9CC,GAAc,EAGuB,QAAjCT,EAAML,EAAYe,KAAKZ,KAAgB,CAC7C,IAAIa,EAAIX,EAAI,GACRY,EAAUZ,EAAI,GACda,EAASb,EAAIG,MAKjB,GAJAC,GAAQN,EAAIgB,MAAMX,EAAOU,GACzBV,EAAQU,EAASF,EAAEI,OAGfH,EACFR,GAAQQ,EAAQ,GAChBH,GAAc,MAFhB,CAMA,IAAIO,EAAO,GACPzC,EAAOyB,EAAI,GACXiB,EAAUjB,EAAI,GACdkB,EAAQlB,EAAI,GACZmB,EAAWnB,EAAI,GAEnB,IAAKS,GAAeL,EAAKW,OAAQ,CAC/B,IAAIK,EAAIhB,EAAKW,OAAS,EAClBM,EAAIjB,EAAKgB,KACCb,GAAYA,EAAUe,QAAQD,IAAM,KAGhDL,EAAOK,EACPjB,EAAOA,EAAKU,MAAM,EAAGM,IAKrBhB,IACFH,EAAOsB,KAAKnB,GACZA,EAAO,GACPK,GAAc,GAGhB,IAEIe,EAAUP,GAAWC,EACrBZ,EAAYU,GAAQX,EAExBJ,EAAOsB,KAAK,CACVhD,KAAMA,GAAQ2B,IACduB,OAAQT,EACRV,UAAWA,EACXoB,SAR0B,MAAbP,GAAiC,MAAbA,EASjCQ,OAVwB,MAAbR,GAAiC,MAAbA,EAW/BK,QAASA,EACLI,EAAYJ,GACZ,KAAOK,EAAavB,IAAcD,EAAmBC,EAAaA,EAAYD,GAAqB,SAS3G,OAJID,GAAQD,EAAQL,EAAIiB,SACtBd,EAAOsB,KAAKnB,EAAON,EAAIgC,OAAO3B,IAGzBF,EA0BT,SAASX,EAAkByC,EAAIC,GAC7B,OAAiBC,SAAAA,EAAUlC,GACzB,IAAIY,EAAIoB,EAAGrB,KAAKuB,GAChB,IAAKtB,EAAG,OAOR,EAAA,IALA,IAAIP,EAAOO,EAAE,GACTR,EAAQQ,EAAER,MACV+B,EAAS,GACTC,EAAUpC,GAAWA,EAAQoC,QAAWC,mBAEnCC,EAAI,EAAGA,EAAI1B,EAAEI,OAAQsB,IAC5B,QAAa7B,IAATG,EAAE0B,GAAN,CAEA,IAAInC,EAAM8B,EAAKK,EAAI,GAGjBH,EAAOhC,EAAI3B,MADT2B,EAAIyB,OACahB,EAAE0B,GAAGC,MAAMpC,EAAII,WAAWiC,IAAI,SAAUC,GACzD,OAAOL,EAAOK,EAAOtC,KAGJiC,EAAOxB,EAAE0B,GAAInC,GAIpC,MAAO,CAAEE,KAAMA,EAAMD,MAAOA,EAAO+B,OAAQA,IAO/C,SAAS1C,EAAkBS,EAAQF,GAKjC,IAHA,IAAI0C,EAAU,IAAIC,MAAMzC,EAAOc,QAGtBsB,EAAI,EAAGA,EAAIpC,EAAOc,OAAQsB,IACR,iBAAdpC,EAAOoC,KAChBI,EAAQJ,GAAK,IAAIzC,OAAO,OAASK,EAAOoC,GAAGb,QAAU,KAAMmB,EAAM5C,KAIrE,OAAiB6C,SAAAA,EAAM7C,GAKrB,IAJA,IAAIK,EAAO,GACPyC,EAAU9C,GAAWA,EAAQ8C,QAAWC,mBACxCC,GAAWhD,IAA+B,IAArBA,EAAQgD,SAExBV,EAAI,EAAGA,EAAIpC,EAAOc,OAAQsB,IAAK,CACtC,IAAIW,EAAQ/C,EAAOoC,GAEnB,GAAqB,iBAAVW,EAAX,CAKA,IACIC,EADAT,EAAQI,EAAOA,EAAKI,EAAMzE,WAAQiC,EAGtC,GAAIkC,MAAMQ,QAAQV,GAAlB,CACE,IAAKQ,EAAMrB,OACT,MAAUwB,IAAAA,UAAU,aAAeH,EAAMzE,KAAO,kCAGlD,GAAqB,IAAjBiE,EAAMzB,OAAc,CACtB,GAAIiC,EAAMtB,SAAU,SAEpB,MAAUyB,IAAAA,UAAU,aAAeH,EAAMzE,KAAO,qBAGlD,IAAK,IAAI6E,EAAI,EAAGA,EAAIZ,EAAMzB,OAAQqC,IAAK,CAGrC,GAFAH,EAAUJ,EAAOL,EAAMY,GAAIJ,GAEvBD,IAAaN,EAAQJ,GAAGgB,KAAKJ,GAC/B,MAAUE,IAAAA,UAAU,iBAAmBH,EAAMzE,KAAO,eAAiByE,EAAMxB,QAAU,KAGvFpB,IAAe,IAANgD,EAAUJ,EAAMvB,OAASuB,EAAM1C,WAAa2C,QAMzD,GAAqB,iBAAVT,GAAuC,iBAAVA,GAAuC,kBAAVA,GAWrE,IAAIQ,EAAMtB,SAEV,MAAUyB,IAAAA,UAAU,aAAeH,EAAMzE,KAAO,YAAcyE,EAAMrB,OAAS,WAAa,iBAb1F,CAGE,GAFAsB,EAAUJ,EAAOS,OAAOd,GAAQQ,GAE5BD,IAAaN,EAAQJ,GAAGgB,KAAKJ,GAC/B,MAAUE,IAAAA,UAAU,aAAeH,EAAMzE,KAAO,eAAiByE,EAAMxB,QAAU,eAAiByB,EAAU,KAG9G7C,GAAQ4C,EAAMvB,OAASwB,QAtCvB7C,GAAQ4C,EA+CZ,OAAO5C,GAUX,SAASyB,EAAc/B,GACrB,OAAOA,EAAIyD,QAAQ,4BAA6B,QASlD,SAAS3B,EAAaV,GACpB,OAAOA,EAAMqC,QAAQ,eAAgB,QASvC,SAASZ,EAAO5C,GACd,OAAOA,GAAWA,EAAQyD,UAAY,GAAK,IAsE7C,SAAS/D,EAAgBQ,EAAQ+B,EAAMjC,GAWrC,IARA,IAAI0D,GAFJ1D,EAAUA,GAAW,IAEA0D,OACjBC,GAA0B,IAAlB3D,EAAQ2D,MAChBC,GAAsB,IAAhB5D,EAAQ4D,IACdrD,EAAYP,EAAQO,WAAaZ,EACjCkE,EAAW,GAAGxE,OAAOW,EAAQ6D,UAAY,IAAIrB,IAAIV,GAAczC,OAAO,KAAKS,KAAK,KAChFgE,EAAQH,EAAQ,IAAM,GAGjBrB,EAAI,EAAGA,EAAIpC,EAAOc,OAAQsB,IAAK,CACtC,IAAIW,EAAQ/C,EAAOoC,GAEnB,GAAqB,iBAAVW,EACTa,GAAShC,EAAamB,OACjB,CACL,IAAI/B,EAAU+B,EAAMrB,OAChB,MAAQqB,EAAMxB,QAAU,OAASK,EAAamB,EAAM1C,WAAa,MAAQ0C,EAAMxB,QAAU,MACzFwB,EAAMxB,QAENQ,GAAMA,EAAKT,KAAKyB,GAMhBa,GAJAb,EAAMtB,SACHsB,EAAMvB,OAGA,MAAQI,EAAamB,EAAMvB,QAAU,IAAMR,EAAU,MAFrD,IAAMA,EAAU,KAKlBY,EAAamB,EAAMvB,QAAU,IAAMR,EAAU,KAK5D,GAAI0C,EACGF,IAAQI,GAAS,MAAQhC,EAAavB,GAAa,MAExDuD,GAAsB,MAAbD,EAAmB,IAAM,MAAQA,EAAW,QAChD,CACL,IAAIE,EAAW7D,EAAOA,EAAOc,OAAS,GAClCgD,EAAqC,iBAAbD,EACxBA,EAASA,EAAS/C,OAAS,KAAOT,OACrBE,IAAbsD,EAECL,IAAQI,GAAS,MAAQhC,EAAavB,GAAa,MAAQsD,EAAW,OACtEG,IAAgBF,GAAS,MAAQhC,EAAavB,GAAa,IAAMsD,EAAW,KAGnF,OAAWhE,IAAAA,OAAOiE,EAAOlB,EAAM5C,IAejC,SAASV,EAAce,EAAM4B,EAAMjC,GACjC,OAAIK,aAAgBR,OA7HtB,SAAyBQ,EAAM4B,GAC7B,IAAKA,EAAM,OAAO5B,EAGlB,IAAI4D,EAAS5D,EAAKlC,OAAO+F,MAAM,aAE/B,GAAID,EACF,IAAK,IAAI3B,EAAI,EAAGA,EAAI2B,EAAOjD,OAAQsB,IACjCL,EAAKT,KAAK,CACRhD,KAAM8D,EACNZ,OAAQ,KACRnB,UAAW,KACXoB,UAAU,EACVC,QAAQ,EACRH,QAAS,OAKf,OAAOpB,EAnBT,CA8H0BA,EAAM4B,GAG1BU,MAAMQ,QAAQ9C,GAnGpB,SAAwBA,EAAM4B,EAAMjC,GAGlC,IAFA,IAAImE,EAAQ,GAEH7B,EAAI,EAAGA,EAAIjC,EAAKW,OAAQsB,IAC/B6B,EAAM3C,KAAKlC,EAAae,EAAKiC,GAAIL,EAAMjC,GAAS7B,QAGlD,OAAW0B,IAAAA,OAAO,MAAQsE,EAAMrE,KAAK,KAAO,IAAK8C,EAAM5C,IAPzD,CAoGgDK,EAAO4B,EAAMjC,GAlF7D,SAAyBK,EAAM4B,EAAMjC,GACnC,OAAON,EAAeF,EAAMa,EAAML,GAAUiC,EAAMjC,GADpD,CAqF+CK,EAAO4B,EAAMjC,GAzR5D,EAAA,MAAA,SAAgBD,EAAKC,GACnB,IAAIiC,EAAO,GAEX,OAAO1C,EADED,EAAaS,EAAKkC,EAAMjC,GACLiC,IAV9B,EAAA,iBAAA,EAAA,EAAA,MAAA,EAAA,EAAA,QAAA,SAAkBlC,EAAKC,GACrB,OAAOP,EAAiBD,EAAMO,EAAKC,GAAUA,ICxGlCoE,EAAAA,iBAAAA,EAAAA,EAAAA,eAAAA,EAAAA,IAAAA,EAAoC,CAC/CC,UAAW,YACXC,QAAS,UACTC,UAAW,YACX7C,OAAQ,aACR8C,QAAS,UACTC,QAAS,WCuKLC,EAAM,IAzKZ,WAAA,SACUtG,IAAAA,KAA0BgG,EAAAA,EAC1BhG,KAAqB,EAAA,IAAIuG,UAFnC,IAOSC,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,SAAA,SAASC,GACd,OAAOA,EAAGC,WAQLC,EAAAA,WAAA,SAAWC,GAChB,OAAYC,KAAAA,EAAQC,gBAAgBF,EAAY,cAS3CG,EAAAA,UAAA,SAAUH,GACf,IAAMI,EAAMC,SAASC,cAAc,OAGnC,OADAF,EAAIG,UAAYP,EACTI,GAMFI,EAAAA,QAAA,SAAQC,GACb,YADaA,IAAAA,IAAAA,EAAoBJ,UACrBT,KAAAA,SAASa,EAAIC,kBAapBC,EAAAA,WAAA,SAAWC,GAChB,YADgBA,IAAAA,IAAAA,EAAeP,UACxBO,EAAMC,cACPzH,IAAAA,KAAK0H,EAAMpE,OAAWtD,KAAAA,KAAK0H,EAAMrB,QAOlCsB,OAAAA,EAAAA,aAAA,SAAaH,GAClB,YADkBA,IAAAA,IAAAA,EAAeP,UAC1BO,EAAMC,cACPzH,IAAAA,KAAK0H,EAAMpE,OAAWtD,KAAAA,KAAK0H,EAAMzB,UAOlC2B,OAAAA,EAAAA,gBAAA,SAAgB3B,GACjBgB,SAAS/H,KAAK2I,SAAS5B,IACzBA,EAAU6B,WAAWC,YAAY9B,IAO9B+B,EAAAA,aAAA,SAAa/B,EAAwBI,GAC1C,IAAM4B,EAAoBjI,KAAK2H,eAE3BM,EACFjI,KAAKkI,EAAajC,EAAWgC,GAE7B5B,EAAQ8B,YAAYlC,IAOjBmC,EAAAA,aAAA,SAAaZ,QAAAA,IAAAA,IAAAA,EAAeP,UACjC,IAAMoB,EAAKb,EAAMC,cACXzH,IAAAA,KAAK0H,EAAMpE,OAAUtD,IAAAA,KAAK0H,EAAMvB,UAGtC,KAAA,OAAOkC,EACHA,EAAGC,aAAgBtI,KAAK0H,EAAMpE,OAAUtD,IAAAA,KAAK0H,EAAMvB,WACnD,MAMCoC,EAAAA,QAAA,SAAQ9B,GAEb,GAAIA,EAAG+B,SAAwC,MAA7B/B,EAAG+B,QAAQC,cAAuB,CAElD,GAAuB,iBAAZhC,EAAGiC,KACZ,OAAOjC,EAAGiC,KAIZ,IAAMA,EAAOjC,EAAG6B,aAAa,SAAW7B,EAAG6B,aAAa,cAGxD,GAAII,EAKF,OAAYC,KAAAA,WAFRD,EAAuCE,SAAWF,GAK1D,OAOKC,MAAAA,EAAAA,WAAA,WAAcE,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EACnB,GAAA,UAAA,GAAA,IAAMC,EAAUD,EAAKjG,OAErB,GAAgB,IAAZkG,EACF,MAAUC,IAAAA,MAAM,wDAGlB,IAAMC,EAAO/B,SAASC,cAAc,QAGpC,GAFA8B,EAAKN,KAAOO,UAAU,GAEN,IAAZH,EACF,OAAOE,EAAKN,KAGd,IAAMQ,EAAOjC,SAASkC,qBAAqB,QAAQ,GACnDD,EAAKE,aAAaJ,EAAME,EAAKG,YAK7B,IAHA,IACIC,EADEC,EAAItC,SAASC,cAAc,KAGxBlF,EAAQ,EAAGA,EAAQ8G,EAAS9G,IACnCuH,EAAEb,KAAOO,UAAUjH,GAEnBgH,EAAKN,KADLY,EAAWC,EAAEb,KAMf,OAFAQ,EAAKnB,YAAYiB,GAEVM,GAMDpB,EAAAA,EAAA,SAAasB,EAAeC,GAClCA,EAAc3B,WAAWsB,aAAaI,EAASC,EAAcC,cCmF3DxD,EDxPN,ICwPMA,EAAU,IAzNhB,WAAA,SAEUlG,IAAAA,KAAwB,EAAA,GACxBA,KAAY,GAAA,EAHtB,IAQS2J,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,KAAA,SAAKC,EAAavB,GACvBrI,KAAK6J,EAAW,QAChB,IAEMC,EAAoB,CACxBzB,GAAAA,EACA0B,OAAQ,CACNC,EAAGC,OAAOC,QACVC,EAAGF,OAAOG,SAEZR,IAAAA,GAGF5J,KAAKqK,EAAQjH,KAAK0G,GAClB9J,KAAKsK,EAZS,EAcd,IAAMC,EAAqB,CACzBC,KAAMxK,KAAK6J,EACX7H,MAhBY,EAiBZyI,OAAYzK,GAAAA,OAAAA,KAAKqK,IAGnBJ,OAAO/D,SAAW+D,OAAO/D,QAAQwE,aAAaH,EAAM,GAAIX,IAGnDe,EAAAA,OAAA,SACLf,EACAgB,EACAvL,GAEA,GAAIA,GAAMA,EAAoByK,MAAO,CAG3BA,IAAAA,EAAmCzK,EAAnCyK,MACA9H,EAAU8H,EAAV9H,MAGR4I,EAAU5K,KAAK6K,EAFF7K,KAAKsK,EAAWtI,GAK7BhC,KAAKoF,QAAQ0E,EAAMW,QACnBzK,KAAKsK,EAAWtI,OAGhBhC,KAAK8K,IAAIlB,EAAKgB,GAGhB,OAAOA,GAMFE,EAAAA,IAAA,SAAIlB,EAAagB,GAEtB,IACM5I,EAAQhC,KAAK+K,KACbC,EAAShL,KAAKiL,EAAWL,GACzBd,EAAoB,CACxBzB,GAJS,MAKT0B,OAAQ,CACNC,EAAGC,OAAOC,QACVC,EAAGF,OAAOG,SAEZR,IAAAA,GAGF5J,KAAKqK,EAAQjH,KAAK0G,GAClB9J,KAAKsK,EAAWtI,EAEhB,IAAMuI,EAAqB,CACzBC,KAAMxK,KAAK6J,EACX7H,MAAAA,EACAyI,OAAYzK,GAAAA,OAAAA,KAAKqK,IAGnB,OAAQW,GACN,IAAK,OACHf,OAAO/D,SAAW+D,OAAO/D,QAAQgF,UAAUX,EAAM,GAAIX,GACrD,MACF,IAAK,UACHK,OAAO/D,SAAW+D,OAAO/D,QAAQwE,aAAaH,EAAM,GAAIX,KAUvDuB,EAAAA,OAAA,SAAO1G,EAAWP,GACvB,IAAMlC,EAAQkC,GAAKlE,KAAKsK,EAElBR,EADW9J,EAAAA,GAAAA,KAAKoL,IAAIpJ,GAGrByC,GAAAA,GAGLzE,KAAKqL,IAAIrJ,EAAO8H,IAMXwB,EAAAA,OAAA,SAAOpH,GACRA,EACFlE,KAAKqK,EAAQkB,OAAOrH,EAAG,GAEvBlE,KAAKqK,EAAQmB,MAGfxL,KAAKsK,KAMAmB,EAAAA,MAAA,WACLzL,KAAKqK,EAAU,GACfrK,KAAKsK,GAAY,GAMZlF,EAAAA,QAAA,SAAQsG,GACb1L,KAAKqK,EAAUqB,GAMVN,EAAAA,IAAA,SAAIpJ,GACT,OAAYqI,KAAAA,EAAQrI,IAMfqJ,EAAAA,IAAA,SAAInH,EAAW4F,GACpB,OAAaO,KAAAA,EAAQnG,GAAK4F,GAkCpBmB,EAAAA,EAAA,SAAWL,GACjB,IAAII,EAAwB,OAItBvE,EAAKmE,EACLe,EAAU3F,EAAgB1C,OAAU0C,IAAAA,EAAgBE,QAM1D,OAJIO,EAAGmF,cAAgBnF,EAAGmF,aAAaD,KACrCX,EAASvE,EAAG6B,aAAaqD,IAGpBX,GAMDH,EAAAA,EAAA,SAAcgB,GAEpB,OAAIC,KAAKC,IAAIF,GAAQ,EAEZA,EAAO,EAAI,UAAY,OAEjB,IAATA,EACK,WAGAA,EAAO,EAAI,OAAS,WAvD/B,EAAA,EAAA,CAAA,CAAA,IAAA,UAAA,IAAA,WAAA,OAAYxB,KAAAA,EAAQrK,KAAKsK,KAOzB,CAAA,IAAA,QAAA,IAAA,WAAA,OAAYD,KAAAA,EAAQrK,KAAKqK,EAAQzH,OAAS,KAO1C,CAAA,IAAA,WAAA,IAAA,WAAA,OAAY0H,KAAAA,EAAW,EAAI,KAAOtK,KAAKqK,EAAQrK,KAAKsK,EAAW,KAO/D,CAAA,IAAA,OAAA,IAAA,WAAA,OAAYD,KAAAA,EAAQzH,WC7MXuI,ED4Bb,IC5BaA,EACXa,SAAAA,EACAvH,GAGKA,IAAAA,IAAAA,EAAAA,WAAAA,IAAAA,EAAKwH,KAAKC,KACMF,OAAAA,QAAAA,QAAAA,GAAbE,KAAAA,SAAAA,GACED,IAAAA,EAASxH,EAATwH,KAEJC,GAAAA,EAGF,CAAA,IAAMC,EAAe7F,EAAIS,UAAUmF,GAEnCD,EAAK9F,UAAYG,EAAI8B,aAAa+D,GAClCF,EAAKhG,UAAYK,EAAIqB,aAAawE,GAIlCF,EAAKC,KAAOA,EAGZhG,EAAQiF,OAAO,CAAE9C,GAAI4D,EAAK9F,YAGRG,IAAAA,EAAAA,EAAIK,WAAWuF,GAEjCjF,SAASmF,MAFDA,EAAAA,SApBP3H,GALY,OAAA,QAAA,QAAA,GAAA,EAAA,KAAA,EAAA,KAAA,mBAAA,GAAA,MAoDbvD,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAemL,EAjBG,EAAA,CAAA,UAAA,KAAA,OAAA,EAAA,SAAA,WAClBC,OAAAA,IAAAA,QAAQ,SAAAC,GACVtC,OAAOuC,sBAAsBD,MCtCpBE,aAAAA,GAAAA,EAAY,WAAMxC,OAAAA,OAAOyC,SAASC,QAKlCC,EAAU,SAAChD,GAAAA,YAAAA,IAAAA,IAAAA,EAAcK,OAAOyC,SAAShE,MAAStH,EAAMwI,GAAKiD,MAoB7DzL,EAAQ,SAACwI,GAEpB,IAAIiD,EACEvI,EAAUsF,EAAI9D,MAAM,QAE1B,GAAgB,OAAZxB,EACE,QAAQY,KAAK0E,KACfiD,EAAO,IAGL,SAAS3H,KAAK0E,KAChBiD,EAAO,SAEJ,CACL,IAAMC,EAAaxI,EAAQ,GAAGyI,UAAU,GAExCF,EAAOG,SAASF,EAAY,IAI9B,IACIG,EADAhL,EAAO2H,EAAIxE,QAAQqH,IAAa,IAEhCS,EAAQ,GAGNC,EAAYlL,EAAKkB,QAAQ,KAE3BgK,GAAa,IACfF,EAAOhL,EAAKU,MAAMwK,EAAY,GAC9BlL,EAAOA,EAAKU,MAAM,EAAGwK,IAIvB,IAAMC,EAAanL,EAAKkB,QAAQ,KAOhC,OALIiK,GAAc,IAChBF,EAAQG,EAAWpL,EAAKU,MAAMyK,EAAa,IAC3CnL,EAAOA,EAAKU,MAAM,EAAGyK,IAGhB,CACLH,KAAAA,EACAhL,KAAAA,EACA4K,KAAAA,EACAK,MAAAA,IAOSG,EAAa,SAAC1L,GACzBA,OAAAA,EAAIwC,MAAM,KAAKmJ,OAAO,SAACC,EAAqB9G,GACrBA,IAAAA,EAAAA,EAAGtC,MAAM,KAI9B,OAFAoJ,EAEOA,EAAAA,IAAAA,EAAAA,GAAAA,GACN,KAKQC,EAAQ,SAAC5D,GAAAA,YAAAA,IAAAA,IAAAA,EAAcK,OAAOyC,SAAShE,MAClDkB,EAAIxE,QAAQ,kBAAmB,KA9FV,EAAA,CAAA,UAAA,KAAA,QAAA,WAAM6E,OAAAA,OAAOyC,SAAShE,MAetB,UAAA,EAAA,QAAA,EAAA,QAAA,SAACkB,GAAAA,YAAAA,IAAAA,IAAAA,EAAcK,OAAOyC,SAAShE,MAAStH,EAAMwI,GAAK3H,MCX1E,MAAA,EAAA,WAAA,EAAA,MAAA,GAAA,SAASwL,EACP7D,EACA8D,EACAC,GAEA,YAHAD,IAAAA,IAAAA,EAAc,KAGHpB,IAAAA,QAAQ,SAACC,EAASqB,GAC3B,IAAMC,EAAM,IAAIC,eAEhBD,EAAIE,mBAAqB,WACvB,GAAIF,EAAIG,aAAeF,eAAeG,KACpC,GAAmB,MAAfJ,EAAIK,OACN3B,EAAQsB,EAAIM,mBACHN,GAAAA,EAAIK,OAAQ,CAErB,IAAMrM,EAAM,CACVqM,OAAQL,EAAIK,OACZE,WAAYP,EAAIO,YAElBT,EAAa/D,EAAK/H,GAClB+L,EAAO/L,KAIbgM,EAAIQ,UAAY,WACd,IAAMC,EAAM,IAAIvF,MAAwB2E,kBAAAA,EACxCC,KAAAA,EAAa/D,EAAK0E,GAClBV,EAAOU,IAETT,EAAIU,QAAU,WACZ,IAAMD,EAAM,IAAIvF,MAChB4E,eAAAA,EAAa/D,EAAK0E,GAClBV,EAAOU,IAGTT,EAAIW,KAAK,MAAO5E,GAChBiE,EAAIY,QAAUf,EACdG,EAAIa,iBACF,SACA,mDAEFb,EAAIa,iBAAiB,UAAW,OAChCb,EAAIc,SC/DR,IAEA,EAAA,SAAmBC,GACjB,QAASA,IAAuB,iBAARA,GAAmC,mBAARA,IAA2C,mBAAbA,EAAItP,MCCvEuP,SAAAA,EACdC,EACAC,GAEA,YAFAA,IAAAA,IAAAA,EAAW,IAEAC,WAAAA,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EACT,GAAA,UAAA,GAAA,IAAIC,GAAQ,EA2BZ,OAzBgB,IAAI3C,QAAQ,SAACC,EAASqB,GAEpCmB,EAAIE,MAAQ,WAGV,OAFAA,GAAQ,EAEAX,SAAAA,EAAUjK,GACZiK,EACFV,EAAOU,GAEP/B,EAAQlI,KAKd,IAAM6K,EAASJ,EAAK9N,MAAM+N,EAAKC,GAE1BC,IACCE,EAAUD,GACXA,EAAwB5P,KAAKiN,EAASqB,GAEvCrB,EAAQ2C,OC4GZE,IAAAA,EAAQ,IAnEZ,SAAA,GAAA,SACEC,IAAAA,IAAAA,EAAAA,OAAAA,EApCsB,EAAA,KAAA,OAAA,MAAA,OAAA,IAAIvP,EAAO,eAO5BuP,EAAkB,IAAA,CACvB,QACA,OACA,QACA,eACA,iBACA,YACA,cACA,aACA,OACA,YACA,SACA,cACA,QACA,aACA,cACA,QACA,aACA,SAQKA,EAA6C,WAAA,IAAIC,IAItDD,EAAK1F,OA3CT,EAAA,EAAA,EAAA,GAAA,IA8CSA,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,KAAA,WACL3J,IAAAA,EAAAA,KAAAA,KAAKuP,WAAW9D,QAChBzL,KAAKwP,IAAIC,QAAQ,SAAAC,GACVC,EAAKD,KACRC,EAAKD,GAAQ,SAAC5O,EAAkBiO,GACzBY,EAAKJ,WAAWK,IAAIF,IACvBC,EAAKJ,WAAWlE,IAAIqE,EAAM,IAAIG,KAEpBF,EAAKJ,WAAWnE,IAAIsE,GAE5B5E,IAAI,CACNiE,IAAKA,GAAO,GACZjO,GAAAA,SAYH,EAAA,GAAA,SAAGV,GAAmB4O,IAAAA,IAAAA,EAAAA,KAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAC3B,EAAA,GAAA,UAAA,GAAA,GAAIhP,KAAKuP,WAAWK,IAAIxP,GAAO,CAE7B,IAAI0P,EAAQxD,QAAQC,UAOpB,OALAvM,KAAKuP,WAAWnE,IAAIhL,GAAMqP,QAAQ,SAAAC,GAEhCI,EAAQA,EAAMxQ,KAAK,WAAMuP,OAAAA,EAASa,EAAK5O,GAAI4O,EAAKX,KAAQC,WAAAA,EAAAA,OAGnDc,EAAY,MAAA,SAAAzP,GACjB0P,EAAKC,OAAOpP,MAAqBR,eAAAA,EACjC2P,KAAAA,EAAKC,OAAO3P,MAAMA,KAItB,OAAOiM,QAAQC,WAGVd,EAAAA,MAAA,WACLzL,IAAAA,EAAAA,KAAAA,KAAKwP,IAAIC,QAAQ,SAAAC,UACRO,EAAKP,KAGd1P,KAAK2J,QAMAuG,EAAAA,KAAA,WACLlQ,KAAKgQ,OAAOrP,KAAyBX,oBAAAA,KAAKwP,IAAI9N,KAAK,MACnD,IAAM6N,EAAuB,GAC7BvP,KAAKuP,WAAWE,QAAQ,SAACpL,EAAOtC,GAAQwN,OAAAA,EAAWnM,KAAKrB,KACxD/B,KAAKgQ,OAAOrP,KAA0B4O,qBAAAA,EAAW7N,KAAK,OAxG/B/B,EAyCzB,CXlDF,eYFawQ,EAIX,WAAA,SAAYC,EAAAA,GACV,GAHMpQ,KAA2B,EAAA,GAGX,kBAAXoQ,EACTpQ,KAAKqQ,EAAaD,MACb,CACL,IAAME,EAAQ/L,MAAMQ,QAAQqL,GAAUA,EAAS,CAACA,GAEhDpQ,KAAKuQ,EAAiBD,EAAMlM,IAAI,SAAAoM,GAAKtP,OAAAA,EAAasP,MAI/CC,OAAAA,EAAAA,UAAAA,UAAA,SAAU/H,GACf,GAA+B,kBAAf2H,KAAAA,EACd,OAAYA,KAAAA,EAGNpO,IAAAA,EAASb,EAAMsH,GAAfzG,KAER,OAAYsO,KAAAA,EAAeG,KAAK,SAAAC,GAA8B,OAAA,OAArBA,EAAMpO,KAAKN,MCzB3C2O,EDQX,GCRWA,EAGX,SAAA,GAAA,SAAYR,EAAAA,GACVf,IAAAA,EAAAA,OAAAA,EAAMe,EAAAA,KAAAA,KAAAA,IAHkC,MAAA,EAAA,IAAId,IADhD,EAAA,EAAA,EAAA,GAAA,IAUSjE,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAA,SACL3C,EACA+E,EACAzC,GAOA,OALAhL,KAAK6Q,EAAOxF,IAAI3C,EAAM,CACpBsC,OAAAA,EACAyC,QAAAA,IAGK,CACLzC,OAAAA,EACAyC,QAAAA,IAOGrC,EAAAA,IAAA,SAAI1C,GACT,OAAYmI,KAAAA,EAAOzF,IAAI1C,IAMlBoI,EAAAA,WAAA,SAAWpI,GAChB,OAAYmI,KAAAA,EAAOzF,IAAI1C,GAAM+E,SAMxBsD,EAAAA,UAAA,SAAUrI,GACf,OAAYmI,KAAAA,EAAOzF,IAAI1C,GAAMsC,QAMxB4E,EAAAA,IAAA,SAAIlH,GAET,OAAI1I,KAAKyQ,UAAU/H,IAGPmI,KAAAA,EAAOjB,IAAIlH,IAMlB,EAAA,OAAA,SAAOA,GACZ,OAAYmI,KAAAA,EAAcnI,OAAAA,IAMrByC,EAAAA,OAAA,SAAOzC,EAAcjE,GAC1B,IAAMqF,EACD9J,EAAAA,GAAAA,KAAK6Q,EAAOzF,IAAI1C,GAChBjE,GAAAA,GAIL,OAFAzE,KAAK6Q,EAAOxF,IAAI3C,EAAMoB,GAEfA,GA3EgBqG,EAGzB,CAHyBA,GCSrBjF,EAA0B,WAAOjB,OAAAA,OAAO/D,QAAQgF,WAKhD8F,EAAuB,SAAGvK,GAAAA,OAAAA,EAAAA,KAAIiC,EAAAA,MAK9BuI,EAAuB,SAAGC,GAAAA,IAAAA,EAAAA,EAAAA,MAC7BA,OAAAA,EAAwBC,MAAQ,GAChCD,EAAwBE,SACxBF,EAAwBG,SACxBH,EAAwBI,UACxBJ,EAAwBK,QAKrBC,EAAsB,SAAG/K,GAAAA,IAAAA,EAAAA,EAAAA,GAC7BA,OAAAA,EAAGmF,aAAa,WAAqC,WAAvBnF,EAAYgL,QAMtCC,EAA2B,SAAGjL,GAAAA,IAAAA,EAAAA,EAAAA,GACMpE,YAAAA,IAAtCoE,EAAyBkL,UACzB1H,OAAOyC,SAASiF,WAAclL,EAAyBkL,eACjBtP,IAAtCoE,EAAyBmL,UACzB3H,OAAOyC,SAASkF,WAAcnL,EAAyBmL,UAMrDC,EAAyB,SAAGpL,GAAAA,IAAAA,EAAAA,EAAAA,GACGpE,YAAAA,IAAlCoE,EAAyBoG,MAC1BjD,MAAkBA,EAAanD,EAAyBiC,OAKpDoJ,EAAyB,SAAGrL,GAAAA,IAAAA,EAAAA,EAAAA,GAChCA,OAAAA,EAAG6B,cAAuD,iBAAhC7B,EAAG6B,aAAa,aAKtCyJ,EAA4B,SAAGtL,GAAAA,OAAAA,EAAAA,GAChCmF,aAAgB5F,EAAgB1C,OAAU0C,IAAAA,EAAgBI,UAKzD4L,GAA2B,SAC/BC,GAAAA,OAAAA,QADkCxL,EAAAA,GAE7ByL,QAAYlM,IAAAA,EAAgB1C,OAAU0C,IAAAA,EAAgBI,QAQvD+L,aAAAA,GAAwB,SAAGzJ,GAAAA,IAAAA,EAAAA,EAAAA,KAC/BkB,OAAAA,EAAUlB,KAAUkB,KAAeA,EAAYlB,KAAUkB,KAE9CwI,GAIX,SAAA,GAAA,SAAYhC,EAAAA,GACVf,IAAAA,EAAAA,OAAAA,EAAMe,EAAAA,KAAAA,KAAAA,IAJiB,MAAA,MAAA,GAClBf,EAAmC,MAAA,IAAIC,IAI5CD,EAAK1F,OANT,EAAA,EAAA,EAAA,GAAA,IASSA,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,KAAA,WAEL3J,KAAK8K,IAAI,YAAaI,GACtBlL,KAAK8K,IAAI,SAAUkG,GACnBhR,KAAK8K,IAAI,SAAUmG,GACnBjR,KAAK8K,IAAI,QAAS0G,GAClBxR,KAAK8K,IAAI,aAAc4G,GACvB1R,KAAK8K,IAAI,WAAY+G,GACrB7R,KAAK8K,IAAI,WAAYgH,GACrB9R,KAAK8K,IAAI,cAAeiH,GACxB/R,KAAK8K,IAAI,aAAckH,IAGvBhS,KAAK8K,IAAI,UAAWqH,IAAS,IAGxBrH,EAAAA,IAAA,SAAI1K,EAAciS,EAAqBC,QAAAA,IAAAA,IAAAA,GAAiB,GAC7DtS,KAAKuS,MAAMlH,IAAIjL,EAAMiS,GACrBC,GAAStS,KAAKsS,MAAMlP,KAAKhD,IAMpBoS,EAAAA,IAAA,SAAIpS,EAAcqG,EAAUyK,EAAcxI,GAC/C,OAAY6J,KAAAA,MAAMnH,IAAIhL,EAAVmS,CAAgB,CAC1B9L,GAAAA,EACAyK,MAAAA,EACAxI,KAAAA,KAOG+J,EAAAA,UAAA,SAAUhM,EAAUyK,EAAcxI,GACvC,IAAA,EAAA,KAAA,OAAY4J,KAAAA,MAAM5B,KAAK,SAAAtQ,GAAQuP,OAAAA,EAAK6C,IAAIpS,EAAMqG,EAAIyK,EAAOxI,MA7ChCyH,EAI3B,CAJ2BA,GC7FhBuC,GAEX,SAAA,GAAA,SACSrS,EAAAA,EACAsS,GAAAA,IAAAA,OAAAA,IAAAA,IAAAA,EAAQ,eACZ5O,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAGHsL,EAAAA,GAAAA,UAAAA,GAAAA,OAAAA,EAAStL,EAAAA,KAAAA,MAAAA,EAAAA,CAAAA,MAAAA,OAAAA,KALF1D,MAAAA,MAAAA,EACAgP,EAAAsD,MAAAA,EAQH5J,MAAM6J,mBACR7J,MAAM6J,kBAAwBF,SAAAA,GAAAA,QAAAA,IAAAA,EAAAA,MAAAA,IAAAA,eAAAA,6DAAAA,OAAAA,EAAAA,CAAAA,GAAAA,GAGhCrD,EAAKjP,KAAO,aAhBhB,EAAA,OAAgC2I,EAAAA,EAAAA,GAAAA,EAE9B,CAF8BA,EAAAA,QC2BnB8J,GAoCX,WAAA,SAAYC,EAAAA,QAAAA,IAAAA,IAAAA,EAAiC,IAnCtC9S,KAAiB,OAAA,IAAIF,EAAO,eAI5BE,KAAyB,IAAA,GAIzBA,KAA0B,KAAA,GAI1BA,KAA0B,KAAA,GASzBA,KAAkB,EAAA,CACxB,CACEI,KAAM,YACN2S,KAAM,WAER,CACE3S,KAAM,SACN2S,KAAM,aASJD,IAEF9S,KAAKwP,IAAMxP,KAAKwP,IAAIvO,OAAO6R,IAE7B9S,KAAKmL,SA1CT,IAgDSL,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAA,SAAIiI,EAA6BtO,GACtC,OAAQsO,GACN,IAAK,OAEH/S,KAAKgT,EAAOzH,OAAO9G,EAAKwO,UAAY,EAAG,EAAGxO,EAAKJ,OAC/C,MACF,IAAK,aACL,QAEErE,KAAKwP,IAAIpM,KAAKqB,GAIlBzE,KAAKmL,UAMAoB,EAAAA,QAAA,SACL9H,EACAyO,GAAAA,IAAAA,EAAAA,UAAAA,IAAAA,IAAAA,EAA8B,IAG9B,IAAIJ,EAAcI,EAAQC,KAAOnT,KAAKmT,KAAOnT,KAAKgM,KAIhD8G,EAAcA,EAAYM,OADxBF,EAAQG,KACuB,SAAAC,GAAKA,OAAAA,EAAElT,MAAmB,SAAXkT,EAAElT,MAEjB,SAAAkT,GAAMA,OAAAA,EAAElT,MAAmB,SAAXkT,EAAElT,OAIrD,IAAMmT,EAAW,IAAIjE,IAIfkE,EAASV,EAAYW,KAAK,SAAAH,GAC9B,IAAII,GAAQ,EACN5N,EAAQ,GAEd,SAAIoN,EAAQG,MAAmB,SAAXC,EAAElT,QAKtBiP,EAAK2D,EAAOW,UAAUlE,QAAQ,SAAAmE,GACxBF,IACFA,EAAQrE,EAAKwE,EAAOP,EAAGM,EAAMnP,EAAMqB,GAE/BwN,EAAE9I,MAAQ8I,EAAEQ,KACdJ,EACErE,EAAKwE,EAAOP,EAAGM,EAAMnP,EAAMqB,EAAO,SAClCuJ,EAAKwE,EAAOP,EAAGM,EAAMnP,EAAMqB,EAAO,OAElCwN,EAAE9I,OAAS8I,EAAEQ,KACfJ,EAAQrE,EAAKwE,EAAOP,EAAGM,EAAMnP,EAAMqB,EAAO,UAEvCwN,EAAE9I,MAAQ8I,EAAEQ,KACfJ,EAAQrE,EAAKwE,EAAOP,EAAGM,EAAMnP,EAAMqB,EAAO,UAKhDyN,EAASlI,IAAIiI,EAAGxN,GAET4N,KAGHK,EAAcR,EAASnI,IAAIoI,GAC3BQ,EAAiB,GAUvB,GAREA,EAAe5Q,KADb8P,EAAQC,KACU,OAEA,QAElBD,EAAQG,MACVW,EAAe5Q,KAAK,QAGlB2Q,EAAa,CAETE,IAAAA,EAAAA,EAAe,CAACT,GAEtBU,OAAOrQ,KAAKkQ,GAAanR,OAAS,GAAKqR,EAAM7Q,KAAK2Q,IAE7C/D,EAAAA,KAAAA,QAAOrP,KACWqT,MAAAA,EAAAA,CAAAA,qBAAAA,EAAetS,KAAK,KACtCuS,KAAAA,OAAAA,SAGLjU,KAAKgQ,OAAOrP,KAA6BqT,wBAAAA,EAAetS,KAAK,KAG/D,KAAA,OAAO8R,GAUFrI,EAAAA,OAAA,WAELnL,IAAAA,EAAAA,KAAAA,KAAKwP,IAAMxP,KAAKwP,IACbpL,IAAI,SAAAkP,GAAK3D,OAAAA,EAAKwE,EAAab,KAC3Bc,KAAK,SAAC7K,EAAG8K,GAAM9K,OAAAA,EAAE+K,SAAWD,EAAEC,WAC9BX,UACAvP,IAAI,SAAAkP,GAGH,cAFOA,EAAEgB,SAEFhB,IAEXtT,KAAKgM,KAAOhM,KAAKwP,IAAI4D,OACnB,SAAAE,GAAiBjR,YAAAA,IAAZiR,EAAEiB,YAAmClS,IAAZiR,EAAEkB,QAElCxU,KAAKmT,KAAOnT,KAAKwP,IAAI4D,OAAO,SAAAE,GAAgBjR,YAAAA,IAAXiR,EAAEH,QAc7BU,EAAAA,EAAA,SACNY,EACAb,EACAnP,EACAqB,EACA4O,GAEA,IAAIC,GAAU,EACVC,GAAW,EACTtB,EAAImB,EACFrU,EAAewT,EAAfxT,KACFyU,EAAUzU,EACV0U,EAAU1U,EACV2U,EAAS3U,EACT4I,EAAO0L,EAAYpB,EAAEoB,GAAapB,EAClCtH,EAAqB,OAAd0I,EAAqBjQ,EAAKwH,KAAOxH,EAAKuQ,QAInD,GAHcN,EAAY1L,GAAQA,EAAK5I,GAAQ4I,EAAK5I,GAGzC,CACT,OAVqBwT,EAATb,MAWV,IAAK,UACL,QAEE,IAAMkC,EAAkB1Q,MAAMQ,QAAQiE,EAAK6L,IACtC7L,EAAK6L,GACN,CAAC7L,EAAK6L,IAGN7I,EAAK6I,KAA8C,IAAlCI,EAAM9R,QAAQ6I,EAAK6I,MACtCD,GAAW,IAGyB,IAAlCK,EAAM9R,QAAQ6I,EAAK6I,MACrBF,GAAU,GAEZ,MAGF,IAAK,SAEH,IAAMM,EAAkB1Q,MAAMQ,QAAQiE,EAAK8L,IACtC9L,EAAK8L,GACN,CAAC9L,EAAK8L,IAGN9I,EAAK8I,IAEL9I,EAAK8I,GAAS1U,OACyB,IAAvC6U,EAAM9R,QAAQ6I,EAAK8I,GAAS1U,QAE5BwU,GAAW,IAG8B,IAAvCK,EAAM9R,QAAQ6I,EAAK8I,GAAS1U,QAC9BuU,GAAU,IAGZA,GAAU,EAEZ,MAGF,IAAK,WACC3L,EAAK+L,GAAQtQ,GACfmQ,GAAW,EAEXD,GAAU,EAKZC,IACEF,GACF5O,EAAM4O,GAAa5O,EAAM4O,IAAc,GACvC5O,EAAM4O,GAAWtU,GAAQkT,EAAEoB,GAAWtU,IAEtC0F,EAAM1F,GAAQkT,EAAElT,IAKtB,OAAOuU,GAWDO,EAAAA,EAAA,SACN5B,EACA6B,EACAC,GAEA,IAAId,EAAW,EAiBf,OAdEhB,EAAE6B,IACD7B,EAAE9I,MAAQ8I,EAAE9I,KAAK2K,IACjB7B,EAAEQ,IAAMR,EAAEQ,GAAGqB,MAEdb,GAAYxI,KAAKuJ,IAAI,GAAID,GAErB9B,EAAE9I,MAAQ8I,EAAE9I,KAAK2K,KACnBb,GAAY,GAEVhB,EAAEQ,IAAMR,EAAEQ,GAAGqB,KACfb,GAAY,IAITA,GAGDH,EAAAA,EAAA,SAAab,GACnBA,IAAAA,EAAAA,KAAAA,EAAEgB,SAAW,EACb,IAAIA,EAAW,EAWf,OATAtU,KAAKgT,EAAOvD,QAAQ,SAACmE,EAAM1P,GAIzBoQ,GAAYvE,EAAKmF,EAAmB5B,EAHnBM,EAATxT,KACM8D,EAAI,KAKpBoP,EAAEgB,SAAWA,EAENhB,GCpTEgC,EDgCX,GChCWA,GAKX,WAAA,SAAYxC,EAAAA,QAAAA,IAAAA,IAAAA,EAAiC,IAJtC9S,KAAiB,OAAA,IAAIF,EAAO,eAE3BE,KAAoB,GAAA,EAG1BA,KAAKuV,MAAQ,IAAI1C,GAAMC,GAN3B,IAcS1H,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAA,SACL3G,EACAyO,GAEA,OAAYqC,KAAAA,MAAMhJ,QAAQ9H,EAAMyO,IA4CrBsC,EAAAA,OACX/Q,SAAAA,GAAAA,IAAAA,EAAAA,EAAAA,KACAgQ,EAAAA,EAAAA,WAmBA9E,IAAAA,IAAAA,EAAAA,WAAAA,EAAK8F,GAAW,GAbhBzV,EAAAA,KADMsT,EAAImB,GAAc,GACxB9E,EAAK8F,GAAW,EAGR9F,IAAAA,EAAAA,EAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAK+F,EAAa,aAAcjR,EAAM6O,IACtC3D,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKwD,KAAK1O,EAAM6O,IAChB3D,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAK+F,EAAa,YAAajR,EAAM6O,IACpCjT,KAAAA,mBAAAA,SAAAA,GACPsP,EAAK8F,GAAW,EAEhB9F,EAAKK,OAAOpP,MAAM,wCAClB+O,EAAKK,OAAO3P,MAAMA,KAhFxB,OAAA,QAAA,QAAA,GAAA,EAAA,KAAA,EAAA,KAAA,GAAA,KAAA,MAgHesV,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,OACXlR,SAAAA,GAAAA,IAAAA,EAAAA,EAAAA,KACAgQ,EAAAA,EAAAA,WACAzI,EAAAA,EAAAA,KACA3F,EAAAA,EAAAA,QA+GA4J,IAAAA,IAAAA,EAAAA,SAAAA,GAAAA,GAAAA,EAAAA,OAAAA,EAAAA,EAAKwF,GAAW,GArGhBzV,GAAAA,EAAAA,EAAAA,KAHMsT,EAAImB,GAAc,GAClBmB,GAAkB,IAAXtC,EAAEsC,OAAiB,EAEhC3F,EAAKwF,GAAW,EAQRxF,IAAAA,EAAAA,EAAAA,WAAAA,SAAAA,IAAAA,OAAAA,QAAAA,QAAAA,EAAKyF,EAAa,SAAUjR,EAAM6O,IAwElCrD,KAAAA,WAAAA,IAAAA,GAAAA,EAAAA,SAAAA,EAAAA,GAAAA,OAAAA,EAAAA,EAAAA,QAAAA,QAAAA,EAAK3E,OAAO7G,IAEZwL,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKyF,EAAa,QAASjR,EAAM6O,IAxEnCsC,KAAAA,gBAAAA,IAAAA,EAAAA,WAAAA,GAAAA,EAEM3F,OAAAA,EAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKnF,IAAIrG,EAAM4B,IAEf4J,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKyF,EAAa,cAAejR,EAAM6O,IACvCrD,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKyF,EAAa,cAAejR,EAAM6O,IAGvChH,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,QAAQkD,IAAI,CAACS,EAAKsE,MAAM9P,EAAM6O,GAAIrD,EAAKuE,MAAM/P,EAAM6O,MAGnDrD,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKyF,EAAa,aAAcjR,EAAM6O,IACtCrD,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKyF,EAAa,aAAcjR,EAAM6O,IACrCjT,KAAAA,yBAAAA,SAAAA,GAGH4P,GAAAA,EAAK4F,EAAmBxV,GAC1B,MAAUqS,IAAAA,GAAWrS,EAAO,6BAiCV,IAAA,EAAA,SAAA,GAAA,OAAA,EAAA,EAAA,EAAA,WAAA,IAAA,EAAA,WAAA,IAAA,IAAhByV,EACI7F,OAAAA,QAAAA,QAAAA,EAAKnF,IAAIrG,EAAM4B,IAEf4J,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKyF,EAAa,cAAejR,EAAM6O,IACvCrD,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKuE,MAAM/P,EAAM6O,EAAGwC,IACpB7F,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKyF,EAAa,aAAcjR,EAAM6O,IAEvCjT,KAAAA,oBAPa,GAObA,GAAAA,GAAAA,EAAAA,KAAAA,OAAAA,EAAAA,KAAAA,eAAAA,SAAAA,GAGH4P,GAAAA,EAAK4F,EAAmBxV,GAC1B,MAAUqS,IAAAA,GACRrS,EACA,4CA1CFyV,GAAmB,EAIf7F,EAAAA,EAAAA,WAAAA,OAAAA,QAAAA,QAAAA,EAAKyF,EAAa,cAAejR,EAAM6O,IAEzBhH,KAAAA,WAAAA,OAAAA,QAAAA,QAAAA,QAAQkD,IAAI,CAC9BS,EAAKsE,MAAM9P,EAAM6O,GACjByC,EAAe/J,EAAMvH,KACpBnF,KAAK,SAAA0W,GAAUA,OAAAA,EAAO,MAPvB,KAAA,SAAA,GAAA,OAIFF,EAKM7F,EAAAA,QAAAA,QAAAA,EAAKyF,EAAa,aAAcjR,EAAM6O,IAIrCjT,KAAAA,mBAAAA,SAAAA,GAGH4P,GAAAA,EAAK4F,EAAmBxV,GAC1B,MAAUqS,IAAAA,GACRrS,EACA,2CAhDJuV,OAAAA,GAAAA,EAAAA,KAAAA,EAAAA,KAAAA,GAAAA,EAAAA,GAMAA,GANAA,OAAAA,GAAAA,EAAAA,KAAAA,EAAAA,KAAAA,GAAAA,EAAAA,KAAAA,IAAAA,EAAAA,WAAAA,GAAAA,EACIG,OAAAA,QAAAA,QAAAA,EAAe/J,EAAMvH,IA8EtBpE,KAAAA,cA/EHuV,GA+EGvV,OAAAA,GAAAA,EAAAA,KAAAA,EAAAA,KAAAA,GAAAA,KAAAA,SAAAA,GAKP,GAJA4P,EAAKwF,GAAW,EAIZpV,EAAMD,MAAuB,eAAfC,EAAMD,KAItB,MAHA6P,EAAKD,OAAOpP,MAAMP,EAAMsS,OACxB1C,EAAKD,OAAO3P,MAAMA,EAAMA,OAElBA,EAMR,MAHA4P,EAAKD,OAAOpP,MAAM,2BAClBqP,EAAKD,OAAO3P,MAAMA,GAEZA,IAhOZ,OAAA,QAAA,QAAA,GAAA,EAAA,KAAA,EAAA,KAAA,GAAA,EAAA,IAAA,MAyOe8S,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,KAAK1O,SAAAA,EAAuB6O,GACjClE,IAAAA,OAAAA,QAAAA,QAAAA,EAAS,GAAA,OAAQ3K,EAAM6O,IAE7B,KAAA,WAAA,OAAOA,EAAEH,KAAOtE,EAASyE,EAAEH,KAAMG,EAAjBzE,CAAoBpK,GAAQ6H,QAAQC,YA5OxD,MAkPegI,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,MAAM9P,SAAAA,EAAuB6O,GAClClE,IAAAA,OAAAA,QAAAA,QAAAA,EAAS,GAAA,QAAS3K,EAAM6O,IAE9B,KAAA,WAAA,OAAOA,EAAEiB,MAAQ1F,EAASyE,EAAEiB,MAAOjB,EAAlBzE,CAAqBpK,GAAQ6H,QAAQC,YArP1D,MA2PeiI,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,MACX/P,SAAAA,EACA6O,EACAwC,GAEM1G,IAAAA,OAAAA,QAAAA,QAAAA,EAAS,GAAA,QAAS3K,EAAM6O,IAE9B,KAAA,WAAA,OAAOA,EAAEkB,MACL3F,EAASyE,EAAEkB,MAAOlB,EAAlBzE,CAAqBpK,EAAMqR,GAC3BxJ,QAAQC,YApQhB,MA0QezB,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,IAAIrG,SAAAA,EAAuB4B,GACtCC,IAAAA,OAAAA,EAAI0B,aAAavD,EAAKwH,KAAKhG,UAAWI,GACtC+I,EAAS,GAAA,YAAa3K,GA5Q1B,QAAA,UAAA,MAkRe6G,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,OAAO7G,SAAAA,GAClB6B,IAAAA,OAAAA,EAAIsB,gBAAgBnD,EAAKuQ,QAAQ/O,WACjCmJ,EAAS,GAAA,iBAAkB3K,GApR/B,QAAA,UAAA,MAuRUoR,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,EAAA,SAAmBxV,GACzB,OAAIA,EAAM4V,SAEA,4BAA4B/Q,KAAK7E,EAAM4V,UAG7C5V,EAAM6N,QAWEwH,EAAAA,EACZhG,SAAAA,EACAjL,EACA6O,GAEMlE,IAAAA,OAAAA,QAAAA,QAAAA,EAASM,GAAAA,EAAMjL,EAAM6O,IAE3B,KAAA,WAAA,OAAOA,EAAE5D,GAAQb,EAASyE,EAAE5D,GAAO4D,EAAlBzE,CAAqBpK,GAAQ6H,QAAQC,YA/S1D,MAyBI,GAAA,OAAA,QAAA,OAAA,KAAA,EAAA,EAAA,CAAA,CAAA,IAAA,YAAA,IAAA,WAAA,OAAYkJ,KAAAA,GAEAvH,IAAAA,SAAAA,GACZlO,KAAKyV,EAAWvH,IAOhB,CAAA,IAAA,UAAA,IAAA,WAAA,OAAYqH,KAAAA,MAAMpC,KAAKvQ,OAAS,IAOhC,CAAA,IAAA,UAAA,IAAA,WAAA,OAAY2S,KAAAA,MAAM/F,IAAIkB,KAAK,SAAA4C,GAAgB,MAAA,SAAXA,EAAElT,SAYlC,CAAA,IAAA,aAAA,IAAA,WAAA,OAAYmV,KAAAA,MAAM/F,IAAIkB,KAAK,SAAA4C,GAAMA,OAAAA,EAAEQ,KAAOR,EAAEQ,GAAGpO,OAAU4N,EAAEsC,WClElDM,EDiBX,GCjBWA,GAkBX,WAAA,SAAYC,EAAAA,GAdLnW,IAAAA,EAAAA,KAAAA,KAAqB,MAAA,CAC1B,cACA,aACA,cACA,cAKKA,KAAkC,YAAA,IAAIsP,IAMtB,IAAjB6G,EAAMvT,SAOVuT,EAAM1G,QAAQ,SAAA2G,GACZ/G,EAAKgH,YAAYhL,IAAI+K,EAAKjQ,UAAWiQ,KAGvCpW,KAAKiV,MAAMxF,QAAQ,SAAArP,GACjBgP,EAAMhP,GAAMiP,EAAKiH,EAAYlW,OAUzBkW,OAAAA,EAAAA,UAAAA,EAAA,SAAYlW,GAClB,IAAA,EAAA,KAAA,OAAOqE,SAAAA,GACiBrE,IAAAA,EAAAA,EAAK0F,MAAM,UAAYrB,EAAKwH,KAAOxH,EAAKuQ,QACxDoB,EAAOzG,EAAK0G,YAAYjL,IADtBjF,EAAAA,WAKR,OAAIiQ,GAAQA,EAAKhW,GACRyO,EAASuH,EAAKhW,GAAOgW,EAArBvH,CAA2BpK,GAG7B6H,QAAQC,YCtEhBgK,EDoCH,GCpCGA,QAAQC,UAAUlS,UACrBiS,QAAQC,UAAUlS,QACfiS,QAAgBC,UAAUC,mBAC3BF,QAAQC,UAAUE,uBAKjBH,QAAQC,UAAUtE,UACrBqE,QAAQC,UAAUtE,QAAU,SAAiByE,GAC3C,IAAIlQ,EAAKzG,KAET,EAAG,CACD,GAAIyG,EAAGnC,QAAQqS,GACb,OAAOlQ,EAGTA,EAAMA,EAAGmQ,eAAiBnQ,EAAGqB,iBACf,OAAPrB,GAA+B,IAAhBA,EAAGoQ,UAE3B,OCZSC,OAAAA,IAAAA,GAA0B,CACrC7Q,UAAW,KACXiG,KAAM,GACN/F,UAAW,GACXyD,IAAK,CACHqD,KAAM,GACNvE,KAAM,GACNzG,KAAM,GACN4K,KAAM,KACNK,MAAO,KtB+kBE,OAAA,IAjjBb,WAAA,SAISlN,IAAAA,KAAkB+W,QAAAA,EAIlB/W,KAA0B8W,WAAAA,GAI1B9W,KAAwBF,OAAAA,EAIxBE,KAAiB,OAAA,IAAIF,EAAO,eAI5BE,KAAoC,QAAA,GAWpCA,KAAQoP,MAAAA,EAYRpP,KAAMsG,IAAAA,EACNtG,KAAU+V,QAAAA,EACV/V,KAAUkG,QAAAA,EACVlG,KAAUyN,QAAAA,EACVzN,KAAM4J,IAAAA,EA/Cf,IA0DSoN,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAA,SAAOC,EAAyBrV,GACrC,IAAMsV,EAAmBlX,KAAKmX,QAG1BD,EAAiB/T,QAAQ8T,IAAW,EACtCjX,KAAKgQ,OAAOvP,KAAgBwW,WAAAA,EAAO7W,KAKP,wBAAA,mBAAnB6W,EAAOG,SAMlBH,EAAOG,QAAQpX,KAAM4B,GACrBsV,EAAiB9T,KAAK6T,IANpBjX,KAAKgQ,OAAOvP,KAAgBwW,WAAAA,EAAO7W,KA2BhCuJ,+BAAAA,EAAAA,KAAA,SAcc,GAAA,IAAA,OAAA,IAAA,EAAA,GAZjBmJ,EAAAA,EAAAA,EAAAA,YAAAA,OAAc,IAAA,EAAA,GACdqD,EAAAA,EAAAA,EAAAA,MAAAA,OAAQ,IAAA,EAAA,GACRkB,EAAAA,EAAAA,EAAAA,OAAAA,OAASrR,IAAAA,EAAAA,EACT2H,EAAAA,EAAAA,EAAAA,aACAc,EAAAA,EAAAA,QAAAA,OAAU,IAAA,EAAA,IACV6I,EAAAA,EAAAA,EAAAA,YAAAA,OACAC,IAAAA,GAAAA,EAAAA,EAAAA,EAAAA,eAAAA,OAEAC,IAAAA,GAAAA,EAAAA,EAAAA,EAAAA,eAAAA,OACApR,IAAAA,GAAAA,EAAAA,EAAAA,EAAAA,QAASqR,OAAgB,IAAA,EAAA,KACzB7W,EAAAA,EAAAA,EAAAA,MACA8W,EAAAA,EAAAA,SAwBF,GApBA5X,EAAOK,UAAmB,UAAO,IAAA,GAAA,GAAA,aAJpB,IAAA,EAAA,MAKbH,GAAAA,KAAKgQ,OAAOrP,KAAKX,KAAK+W,SAGtB7C,OAAOrQ,KAAKwT,GAAQ5H,QAAQ,SAAAxM,GAItB+C,EAHS/C,KAIX+C,EAJW/C,GAIaoU,EAJbpU,MAOfjD,KAAK2X,EAAsBhK,EAC3B3N,KAAKyO,QAAUA,EACfzO,KAAKsX,YAAcA,EACnBtX,KAAKuX,eAAiBA,EACtBvX,KAAKwX,eAAiBA,EAGtBxX,KAAKhB,EAAWgB,KAAKsG,IAAIiB,cACpBvH,KAAKhB,EACR,MAAU+J,IAAAA,MAAM,wCAElB/I,KAAKhB,EAAS4Y,aAAa,YAAa,UAGxC5X,KAAK6X,IAEG7C,IAAAA,EAAYhV,KAAKyE,KAAjBuQ,QAER,IAAKA,EAAQ/O,UACX,MAAU8C,IAAAA,MAAM,0CAUlB,GANA/I,KAAK8X,MAAQ,IAAIlH,EAAM0G,GACvBtX,KAAKoG,QAAU,IAAIgM,GAAQmF,GAC3BvX,KAAK8S,YAAc,IAAIwC,GAAYxC,GACnC9S,KAAKmW,MAAQ,IAAID,GAAMC,GAGD,OAAlBsB,EAAwB,CAC1B,GAA6B,mBAAlBA,EACT,MAAU1O,IAAAA,MAAM,8CAGlB/I,KAAKoG,QAAQ0E,IAAI,gBAAiB2M,GAKpCzX,KAAKkG,QAAQyD,KAAKqL,EAAQpL,IAAIlB,KAAMsM,EAAQ7O,WAM5CnG,KAAK+X,EAAe/X,KAAK+X,EAAaC,KAAKhY,MAC3CA,KAAKiY,EAAejY,KAAKiY,EAAaD,KAAKhY,MAC3CA,KAAKkY,EAAiBlY,KAAKkY,EAAeF,KAAKhY,MAC/CA,KAAKmY,IAGLnY,KAAKmX,QAAQ1H,QAAQ,SAAAwH,GAAUA,OAAAA,EAAOtN,SAItC,IAAMyO,EAAWpY,KAAKyE,KAEtB2T,EAASxN,QAAU,QACnBwN,EAASnM,KAAOmM,EAASpD,QACzBoD,EAASpD,QAAehV,EAAAA,GAAAA,KAAK8W,YAC7B9W,KAAKoP,MAAS,GAAA,QAASgJ,GAGvBpY,KAAKmT,KAAKiF,GAGVpY,KAAK6X,KAGAQ,EAAAA,QAAA,WACLrY,KAAK6X,IACL7X,KAAKsY,IACLtY,KAAKkG,QAAQuF,QACbzL,KAAKoP,MAAM3D,QACXzL,KAAKmX,QAAU,IAcVoB,EAAAA,MAAA,SAAM7P,GAGXuB,OAAOyC,SAAS8L,OAAO9P,IAclB+P,EAAAA,GAAA,SACL/P,EACAkC,EACAvL,GASA,IAAIgU,EANJ,QAJAzI,IAAAA,IAAAA,EAAmB,SAIf5K,KAAK8S,YAAY4F,UACnB1Y,KAAKuY,MAAM7P,QAkBb,KAPE2K,EADc,aAAZzI,EAEA5K,KAAKkG,QAAQ8O,SACbhV,KAAK4J,IAAI+O,QAAQ3Y,KAAKkG,QAAQ8O,QAAQpL,OAAS5J,KAAK4J,IAAI+O,QAAQjQ,GAE3D1I,KAAKoG,QAAQoM,IAAI,UAAW,KAAM,KAAM9J,KAGpC1I,KAAK8S,YAAY8F,QAW9B,OAPAhO,EAAU5K,KAAKkG,QAAQyE,OAAOjC,EAAMkC,EAASvL,GAEzCA,IACFA,EAAEwZ,kBACFxZ,EAAEyZ,kBAGQ9M,KAAAA,KAAKtD,EAAMkC,EAASyI,IASrBF,EAAAA,KAAK4F,SAAAA,GACV/Y,IAAAA,IAAAA,EAAAA,KAAA2P,OAAAA,QAAAA,QAAAA,EAAKP,MAAS,GAAA,cAAe2J,IAW7BpJ,KAAAA,WAAAA,SAAAA,IAAAA,OAAAA,QAAAA,QAAAA,EAAKP,MAAS,GAAA,aAAc2J,IAR9BpJ,KAAAA,cAAAA,IAAAA,EAAAA,WAAAA,GAAAA,EAAKmD,YAAYkG,QACnB,CAAA,IAAMvE,EAAa9E,EAAKmD,YAAY1H,IAAI2N,EAAW,CACjD5F,MAAM,IAGFxD,OAAAA,QAAAA,QAAAA,EAAKmD,YAAY0C,OAAO,CAAEf,WAAAA,EAAYhQ,KAAMsU,KA5RxD,KAAA,eAuRQpJ,GAvRR,OAAA,GAAA,EAAA,KAAA,EAAA,KAAA,GAAA,MAAA,MA+Se3D,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,KACXtD,SAAAA,EACAkC,EACAyI,GAyBA,IAAA,IAAA,EAAA,WAAA,IAAM5O,EAAOwL,EAAKxL,KAIZwL,OAAAA,QAAAA,QAAAA,EAAKb,MAAS,GAAA,OAAQ3K,IAG1B,KAAA,WAAA,IAAA,EAAA,EAAA,WAAA,IAAMgQ,EAAaxE,EAAK6C,YAAY1H,IAAI3G,EAAM,CAC5C0O,MAAM,EACNE,KAAAA,IAHA,OAMIpD,QAAAA,QAAAA,EAAK6C,YAAY6C,OAAO,CAC5BlR,KAAAA,EACAuH,KAAAA,EACAyI,WAAAA,EACApO,QAAS4J,EAAKjR,KAGhBiR,KAAAA,WAAAA,EAAK4H,OAQqB,WAAA,IAAtB/X,EAAOI,YACT+P,EAAKsI,MAAM9T,EAAKuQ,QAAQpL,IAAIlB,QAnDhC1I,GAAAA,GAAAA,EAAAA,KAAAA,OAAAA,EAAAA,KAAAA,iBAAAA,EAAAA,KAAAiQ,EAAKxL,KAAKwH,KAAKrC,IACblB,EAAAA,CAAAA,KAAAA,GACGuH,EAAKrG,IAAIxI,MAAMsH,IAEpBuH,EAAKxL,KAAKmG,QAAUA,EAEpB,IAAMoB,EAAOiE,EAAK6H,MAAMlI,IAAIlH,GACxBuH,EAAK6H,MAAM3M,OAAOzC,EAAM,CAAEsC,OAAQ,UAAWyC,QAC7CwC,EAAK6H,MAAMzM,IACT3C,EACAuH,EAAKxC,QACH/E,EACAuH,EAAKxB,QACLwB,EAAKgJ,eAAejB,KAAWpN,EAAAA,IAEjC,SACA6C,QAGFwC,EAAAA,WAAAA,GAAAA,EAAK6C,YAAYoG,WACbnD,OAAAA,QAAAA,QAAAA,EAAe/J,EAAMiE,EAAKxL,OAxUtC,KAAA,cAuUQwL,GAvUR,OAAA,QAAA,QAAA,GAAA,EAAA,KAAA,EAAA,KAAA,GAAA,KAAA,MAiXSgJ,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,eAAA,SAAerO,GAEpB5K,KAAK8S,YAAY4F,WAAY,EAFY1J,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAIlCtG,EAAAA,GAAAA,UAAAA,GAAAA,IAAAA,EAAoDsG,EAA9CmK,GAAAA,EAA8CnK,EACrDhE,GAAAA,EAAShL,KAAK8X,MAAM/G,UAAUrI,GAIpC,OAHA1I,KAAK8X,MAAapP,OAAAA,KAIhB1I,KAAK2X,IACyD,IAA9D3X,KAAK2X,EAAoB/M,EAASI,EAAQtC,EAAMyQ,KAMnC,UAAXnO,GACFhL,KAAKuY,MAAM7P,GAQR0Q,KAAAA,EAAAA,SAAA,SAAS1Q,GAGV1I,IAAAA,EAAAA,KAAAA,KAAK8X,MAAMlI,IAAIlH,IAInB1I,KAAK8X,MAAMzM,IACT3C,EACA1I,KAAKyN,QACH/E,EACA1I,KAAKyO,QACLzO,KAAKiZ,eAAejB,KAAKhY,KAAM,UACzB,MAAA,SAACK,GACPgZ,EAAKrJ,OAAO3P,MAAMA,KAEpB,aAOI8X,EAAAA,EAAA,YAEsB,IAAxBnY,KAAKuX,iBACPtQ,SAASqS,iBAAiB,YAAatZ,KAAK+X,GAC5C9Q,SAASqS,iBAAiB,aAActZ,KAAK+X,IAE/C9Q,SAASqS,iBAAiB,QAAStZ,KAAKiY,GACxChO,OAAOqP,iBAAiB,WAAYtZ,KAAKkY,IAMnCI,EAAAA,EAAA,YAEsB,IAAxBtY,KAAKuX,iBACPtQ,SAASsS,oBAAoB,YAAavZ,KAAK+X,GAC/C9Q,SAASsS,oBAAoB,aAAcvZ,KAAK+X,IAElD9Q,SAASsS,oBAAoB,QAASvZ,KAAKiY,GAC3ChO,OAAOsP,oBAAoB,WAAYvZ,KAAKkY,IAStCH,EAAAA,EAAA,SAAa1Y,GACbma,IAAAA,EAAAA,KAAAA,EAAOxZ,KAAKyZ,EAAgBpa,GAElC,GAAKma,EAAL,CAIA,IAAM9Q,EAAO1I,KAAKsG,IAAIiC,QAAQiR,GAE1BxZ,KAAKoG,QAAQqK,UAAU/H,IAKvB1I,KAAK8X,MAAMlI,IAAIlH,IAInB1I,KAAK8X,MAAMzM,IACT3C,EACA1I,KAAKyN,QACH/E,EACA1I,KAAKyO,QACLzO,KAAKiZ,eAAejB,KAAKhY,KAAMwZ,IACzB,MAAA,SAACnZ,GACPqZ,EAAK1J,OAAO3P,MAAMA,KAEpB,WAWI4X,EAAAA,EAAA,SAAa5Y,GAEnB,IAAMma,EAAOxZ,KAAKyZ,EAAgBpa,GAElC,GAAKma,EAIL,OAAIxZ,KAAK8S,YAAY4F,WAAa1Y,KAAKwX,gBACrCnY,EAAEyZ,sBACFzZ,EAAEwZ,wBAKJ7Y,KAAKyY,GAAGzY,KAAKsG,IAAIiC,QAAQiR,GAAOA,EAAMna,IAShC6Y,EAAAA,EAAA,SAAe7Y,GACrBW,KAAKyY,GAAGzY,KAAK4J,IAAIrB,UAAW,WAAYlJ,IASlCoa,EAAAA,EAAA,SAAgBpa,GAGtB,IAFA,IAAIoH,EAAKpH,EAAEoS,OAEJhL,IAAOzG,KAAKsG,IAAIiC,QAAQ9B,IAC7BA,EAAMA,EAAmBqB,WAI3B,GAAKrB,IAAMzG,KAAKoG,QAAQqM,UAAUhM,EAAIpH,EAAGW,KAAKsG,IAAIiC,QAAQ9B,IAI1D,OAAOA,GAQDoR,EAAAA,EAAA,WACN,IAAMnP,EAAO1I,KAAK4J,IAAIrB,UAChByM,EAAU,CACd/O,UAAWjG,KAAKsG,IAAIqB,eACpBuE,KAAMlM,KAAKsG,IAAIc,UACfjB,UAAWnG,KAAKsG,IAAI8B,eACpBwB,IACElB,EAAAA,CAAAA,KAAAA,GACG1I,KAAK4J,IAAIxI,MAAMsH,KAItB1I,KAAK2Z,EAAQ,CACX3E,QAAAA,EACA/I,KAAWjM,EAAAA,GAAAA,KAAK8W,YAChBlM,aAASvI,GAGXrC,KAAKoP,MAAS,GAAA,QAASpP,KAAKyE,OAlW5B,EAAA,EAAA,CAAA,CAAA,IAAA,OAAA,IAAA,WAAA,OAAYkV,KAAAA,IAIZ,CAAA,IAAA,UAAA,IAAA,WAAA,OAAY3a,KAAAA,MAAAA,EA/MhB;;;AuBuMyC,IAAA,GAI7B,SAAA,EAAA,GAAA,iBAAA,SAAA,oBAAA,OAAA,OAAA,QAAA,IAAA,mBAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,MAAA,SAAA,IAAA,CAAA,KAAA,WAAA,IAAA,EAAA,SAAA,OAAA,IAhOZ,WAAA,SACSgB,IAAAA,KAAO,KAAA,aACPA,KAAU+W,QAAAA,EAIV/W,KAAiB,OAAA,QACjBA,KAA2B,UAAA,GAI1BA,KAA0B,GAAA,EAXpC,IAgBSoX,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,QAAA,SAAQwC,GACb5Z,KAAKgQ,OAAS,IAAI4J,EAAM9Z,OAAOE,KAAKI,MACpCJ,KAAKgQ,OAAOrP,KAAKX,KAAK+W,SACtB/W,KAAK4Z,MAAQA,EACb5Z,KAAK6Z,EAAQ7Z,KAAK6Z,EAAM7B,KAAKhY,MAC7BA,KAAK8Z,EAAS9Z,KAAK8Z,EAAO9B,KAAKhY,MAC/BA,KAAK+Z,EAAS/Z,KAAK+Z,EAAO/B,KAAKhY,OAM1B2J,EAAAA,KAAA,WAEL3J,KAAK4Z,MAAMxK,MAAM4K,OAAOha,KAAKia,EAAYja,MACzCA,KAAK4Z,MAAMxK,MAAM8K,WAAWla,KAAKia,EAAYja,MAG7CA,KAAK4Z,MAAMxK,MAAM8K,WAAWla,KAAKma,EAAana,MAC9CA,KAAK4Z,MAAMxK,MAAMgL,UAAUpa,KAAKqa,EAAYra,MAC5CA,KAAK4Z,MAAMxK,MAAMkL,YAAYta,KAAKua,EAAcva,MAChDA,KAAK4Z,MAAMxK,MAAMoL,WAAWxa,KAAKya,EAAaza,MAC9CA,KAAK4Z,MAAMxK,MAAMsL,YAAY1a,KAAK2a,EAAc3a,MAChDA,KAAK4Z,MAAMxK,MAAMwL,WAAW5a,KAAK6a,EAAa7a,MAG9CA,KAAK4Z,MAAM9G,YAAYK,KAAOnT,KAAK6Z,EACnC7Z,KAAK4Z,MAAM9G,YAAYyB,MAAQvU,KAAK8Z,EACpC9Z,KAAK4Z,MAAM9G,YAAY0B,MAAQxU,KAAK+Z,EAIpC/Z,KAAK4Z,MAAM9G,YAAYyC,MAAM/F,IAAIsL,QAAQ,CACvC1a,KAAM,QACN+S,KACAoB,aAAAA,MACAC,aAAAA,MAEFxU,eAAAA,KAAK4Z,MAAM9G,YAAYyC,MAAMpK,UAMlB5F,EAAAA,MAAMU,SAAAA,EAAwB8U,GAEzC/a,IAAAA,IAAAA,EAAAA,KAAA2P,OAAAA,EAAK7E,IAAI7E,EAAW8U,GACdpL,QAAAA,QAAAA,EAAKiK,MAAM7D,QAAQiF,YAEzBrL,KAAAA,WAAAA,OAAAA,EAAK7E,IAAI7E,EAAc8U,EACjBpL,WAAAA,QAAAA,QAAAA,EAAKiK,MAAM7D,QAAQiF,YAlE7B,KAAA,gBAAA,MAwEe/O,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,KAAKhG,SAAAA,EAAwB8U,GACxC/a,IAAAA,IAAAA,EAAAA,KAAAiQ,OAAAA,EAAKgL,EAAiBhL,EAAKiL,EAAiBjV,GAExCgK,QAAAA,QAAAA,EAAKgL,EAEI3O,IAAAA,QAAcC,SAAAA,GACvB0D,IAAAA,OAAAA,EAAKkL,GAAK5O,EACV0D,EAAKmL,UAAUL,GAAQxO,EAEvBtG,EAAUqT,iBAAiB,gBAAiB/M,GAAS,GAC/C0D,QAAAA,QAAAA,EAAK2J,MAAM7D,QAAQiF,YACzB/K,KAAAA,WAAAA,OAAAA,EAAK3E,OAAOrF,EAAW8U,GAEvB9K,EAAKnF,IAAI7E,EAAc8U,EACjB9K,OAAAA,QAAAA,QAAAA,EAAK2J,MAAM7D,QAAQiF,YATpB,KAAA,gBAAA,MAYP/K,GAAAA,OAAAA,QAAAA,OAAAA,OAAAA,EAAK3E,OAAOrF,EAAW8U,GACjB9K,QAAAA,QAAAA,EAAK2J,MAAM7D,QAAQiF,YACzB/K,KAAAA,WAAAA,OAAAA,EAAKnF,IAAI7E,EAAc8U,EACjB9K,OAAAA,QAAAA,QAAAA,EAAK2J,MAAM7D,QAAQiF,YA5F/B,KAAA,kBAAA,MAmGexV,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,IAAIS,SAAAA,EAAwB8U,GACvC/a,IAAAA,OAAAA,KAAKsL,OAAOrF,EAAc8U,EAA1B/a,OAAAA,KACKsL,OAAOrF,EAAc8U,EAC1B9U,WAAAA,EAAUsT,oBAAoB,gBAF9BvZ,KAEoDob,UAAUL,IAF9D/a,KAGKib,GAAiB,EAvG1B,QAAA,UAAA,MA6GSnQ,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,IAAA,SAAIrE,EAAiB4U,GAC1B5U,EAAG6U,UAAUxQ,IAAO9K,KAAKsD,OAAU+X,IAAAA,IAM9B/P,EAAAA,OAAA,SAAO7E,EAAiB4U,GAC7B5U,EAAG6U,UAAUhQ,OAAUtL,KAAKsD,OAAU+X,IAAAA,IAMhCpB,EAAAA,EAAA,SAAWxV,EAAuB6O,GACxCtT,KAAKsD,OAASgQ,EAAElT,MAAQ,SAMlB8a,EAAAA,EAAA,SAAiBjV,GAEvB,MAA0D,OAAnDsV,iBAAiBtV,GAAWuV,oBAM7BrB,EAAAA,EAAA,SAAY1V,GAClB,OAAYc,KAAAA,MAAMd,EAAKwH,KAAKhG,UAAW,SAM3B4T,EAAAA,EAAMpV,SAAAA,EAAuB6O,GACnCtT,IAAAA,IAAAA,EAAAA,KAAAyb,OAAAA,QAAAA,QAAAA,EAAK7B,MAAMxK,MAAS,GAAA,OAAQ3K,EAAM6O,IAExC,KAAA,WAAA,OAAYrH,EAAAA,KAAKxH,EAAKwH,KAAKhG,UAAW,UApJ1C,MA0JUoU,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,EAAA,SAAW5V,GACjB,OAAYe,KAAAA,IAAIf,EAAKwH,KAAKhG,UAAW,SAM/BsU,EAAAA,EAAA,SAAa9V,GACnB,OAAYc,KAAAA,MAAMd,EAAKuQ,QAAQ/O,UAAW,UAM9B6T,EAAAA,EACZrV,SAAAA,EACA6O,GAEMtT,IAAAA,IAAAA,EAAAA,KAAA0b,OAAAA,QAAAA,QAAAA,EAAK9B,MAAMxK,MAAS,GAAA,QAAS3K,EAAM6O,IAEzC,KAAA,WAAA,OAAYrH,EAAAA,KAAKxH,EAAKuQ,QAAQ/O,UAAW,WA9K7C,MAoLUwU,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,EAAA,SAAYhW,GAMlB,OALAzE,KAAKwF,IAAIf,EAAKuQ,QAAQ/O,UAAW,SAGjCjG,KAAK4Z,MAAM9G,YAAYxH,OAAO7G,GAEvB6H,QAAQC,WAMToO,EAAAA,EAAA,SAAalW,GAEnB,OAAgC,IAA5BzE,KAAK4Z,MAAM1T,QAAQ6E,KACduB,QAAQC,UAELhH,KAAAA,MAAMd,EAAKwH,KAAKhG,UAAW,UAM3B8T,EAAAA,EACZtV,SAAAA,EACA6O,GAEMtT,IAAAA,IAAAA,EAAAA,KAAA2b,OAAAA,QAAAA,QAAAA,EAAK/B,MAAMxK,MAAS,GAAA,QAAS3K,EAAM6O,IAEzC,KAAA,WAAA,OAAYrH,EAAAA,KAAKxH,EAAKwH,KAAKhG,UAAW,WAjN1C,MAuNU4U,GAAAA,OAAAA,QAAAA,OAAAA,KAAAA,EAAAA,EAAA,SAAYpW,GAElB,OAAgC,IAA5BzE,KAAK4Z,MAAM1T,QAAQ6E,KACduB,QAAQC,UAEL/G,KAAAA,IAAIf,EAAKwH,KAAKhG,UAAW,UAAA,EA5NzC","file":"app.js","sourceRoot":"..","sourcesContent":["/**\n * @barba/core\n * <br><br>\n * ## Barba core object\n *\n * Main methods:\n *\n * - `.init()` for initialization with options\n * - `.use()` for plugins\n *\n * @module core\n */\n\n/***/\n\nimport { version } from '../package.json';\n// Definitions\nimport {\n  IBarbaOptions,\n  IBarbaPlugin,\n  IgnoreOption,\n  ISchemaPage,\n  ITransitionData,\n  ITransitionOnce,\n  ITransitionPage,\n  Link,\n  LinkEvent,\n  RequestCustomError,\n  RequestErrorOrResponse,\n  SchemaAttributeValues,\n  Trigger,\n  Wrapper,\n} from './defs';\n// Hooks\nimport { hooks } from './hooks';\n// Modules\nimport { Cache } from './modules/Cache';\nimport { Logger } from './modules/Logger';\nimport { Prevent } from './modules/Prevent';\nimport { Transitions } from './modules/Transitions';\nimport { Views } from './modules/Views';\n// Polyfills\nimport './polyfills';\n// Schemas\nimport { schemaAttribute } from './schemas/attribute';\nimport { schemaPage } from './schemas/page';\n// Utils\nimport { dom, helpers, history, request, url } from './utils';\n\nexport class Core {\n  /**\n   * Version.\n   */\n  public version: string = version;\n  /**\n   * Schemas.\n   */\n  public schemaPage: ISchemaPage = schemaPage;\n  /**\n   * Logger class, allows plugins to create Logger.\n   */\n  public Logger: typeof Logger = Logger;\n  /**\n   * Barba logger.\n   */\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * Plugins.\n   */\n  public plugins: Array<IBarbaPlugin<any>> = [];\n  /**\n   * Options\n   */\n  public timeout: number;\n  public cacheIgnore: IgnoreOption;\n  public prefetchIgnore: IgnoreOption;\n  public preventRunning: boolean;\n  /**\n   * Hooks\n   */\n  public hooks = hooks;\n  /**\n   * Modules.\n   */\n  // public history: History;\n  public cache: Cache;\n  public prevent: Prevent;\n  public transitions: Transitions;\n  public views: Views;\n  /**\n   * Utils.\n   */\n  public dom = dom;\n  public helpers = helpers;\n  public history = history;\n  public request = request;\n  public url = url;\n\n  private _data: ITransitionData;\n  private _requestCustomError: RequestCustomError;\n  private _wrapper: Wrapper;\n\n  /**\n   * ### Init plugin with options.\n   *\n   * See [[IBarbaPlugin]] for more details.\n   */\n  public use<T>(plugin: IBarbaPlugin<T>, options?: T): void {\n    const installedPlugins = this.plugins;\n\n    // Plugin installation\n    if (installedPlugins.indexOf(plugin) > -1) {\n      this.logger.warn(`Plugin [${plugin.name}] already installed.`);\n\n      return;\n    }\n\n    if (typeof plugin.install !== 'function') {\n      this.logger.warn(`Plugin [${plugin.name}] has no \"install\" method.`);\n\n      return;\n    }\n\n    plugin.install(this, options);\n    installedPlugins.push(plugin);\n  }\n\n  /**\n   * ### Init barba with options.\n   *\n   * See [[IBarbaOptions]] for more details.\n   *\n   * Default values are:\n   *\n   * - transitions: `[]`\n   * - views: `[]`\n   * - schema: [[SchemaAttribute]]\n   * - timeout: `2e3`\n   * - cacheIgnore: `false`\n   * - prefetchIgnore: `false`\n   * - preventRunning: `false`\n   * - prevent: `null`,\n   * - debug: `false`\n   * - logLevel: `'debug'`\n   */\n  public init(\n    /** @ignore */ {\n      transitions = [],\n      views = [],\n      schema = schemaAttribute,\n      requestError,\n      timeout = 2e3,\n      cacheIgnore = false,\n      prefetchIgnore = false,\n      /* istanbul ignore next */\n      preventRunning = false,\n      prevent: preventCustom = null,\n      debug = false,\n      logLevel = 'off',\n    }: IBarbaOptions = {}\n  ) {\n    // 0. Set logger level and print version\n    Logger.setLevel(debug === true ? 'debug' : logLevel);\n    this.logger.info(this.version);\n\n    // 1. Manage options\n    Object.keys(schema).forEach(k => {\n      const attr = k as SchemaAttributeValues;\n\n      /* istanbul ignore else */\n      if (schemaAttribute[attr]) {\n        schemaAttribute[attr] = schema[attr];\n      }\n    });\n    this._requestCustomError = requestError;\n    this.timeout = timeout;\n    this.cacheIgnore = cacheIgnore;\n    this.prefetchIgnore = prefetchIgnore;\n    this.preventRunning = preventRunning;\n\n    // 2. Get and check wrapper\n    this._wrapper = this.dom.getWrapper();\n    if (!this._wrapper) {\n      throw new Error('[@barba/core] No Barba wrapper found');\n    }\n    this._wrapper.setAttribute('aria-live', 'polite'); // A11y\n\n    // 3. Init pages (get \"current\" data)\n    this._resetData();\n\n    const { current } = this.data;\n\n    if (!current.container) {\n      throw new Error('[@barba/core] No Barba container found');\n    }\n\n    // 4. Init other modules\n    this.cache = new Cache(cacheIgnore);\n    this.prevent = new Prevent(prefetchIgnore);\n    this.transitions = new Transitions(transitions);\n    this.views = new Views(views);\n\n    // Add prevent custom\n    if (preventCustom !== null) {\n      if (typeof preventCustom !== 'function') {\n        throw new Error('[@barba/core] Prevent should be a function');\n      }\n\n      this.prevent.add('preventCustom', preventCustom);\n    }\n\n    // 5. Use \"current\" data\n    // Init history\n    this.history.init(current.url.href, current.namespace);\n    // Add to cache\n    // TODO: do not cache renderer HTML, only request results\n    // this.cache.set(current.url.href, Promise.resolve(current.html), 'init');\n\n    // 6. Bind context\n    this._onLinkEnter = this._onLinkEnter.bind(this);\n    this._onLinkClick = this._onLinkClick.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._bind();\n\n    // 7. Init plugins\n    this.plugins.forEach(plugin => plugin.init());\n\n    // 8. Barba ready\n    // Set next + trigger for once and `beforeEnter`/`afterEnter` view on page load.\n    const onceData = this.data;\n\n    onceData.trigger = 'barba';\n    onceData.next = onceData.current;\n    onceData.current = { ...this.schemaPage };\n    this.hooks.do('ready', onceData);\n\n    // 9. Finally, do once\n    this.once(onceData);\n\n    // Clean data for first barba transition\n    this._resetData();\n  }\n\n  public destroy(): void {\n    this._resetData();\n    this._unbind();\n    this.history.clear();\n    this.hooks.clear();\n    this.plugins = [];\n  }\n\n  get data(): ITransitionData {\n    return this._data;\n  }\n\n  get wrapper(): HTMLElement {\n    return this._wrapper;\n  }\n\n  /**\n   * ### Force a page change without Barba transition.\n   */\n  public force(href: string): void {\n    // DEV\n    // Can be used waiting animation cancellation management\n    window.location.assign(href);\n  }\n\n  /**\n   * ### Go for a Barba transition.\n   *\n   * Manage \"self page\" href:\n   *\n   * - if same url and no self transition, keep default behavior\n   *   - link: reload the page\n   *   - anchor: scroll to\n   * - if same url with self transition, use it\n   * - then start a page transition.\n   */\n  public go(\n    href: string,\n    trigger: Trigger = 'barba',\n    e?: LinkEvent | PopStateEvent\n  ): Promise<void> {\n    // If animation running, force reload\n    if (this.transitions.isRunning) {\n      this.force(href);\n\n      return;\n    }\n\n    let self = false;\n\n    // Check prevent sameURL against current history\n    // + state check\n    // + update trigger with direction\n    if (trigger === 'popstate') {\n      self =\n        this.history.current &&\n        this.url.getPath(this.history.current.url) === this.url.getPath(href);\n    } else {\n      self = this.prevent.run('sameUrl', null, null, href);\n    }\n\n    if (self && !this.transitions.hasSelf) {\n      return;\n    }\n\n    trigger = this.history.change(href, trigger, e);\n\n    if (e) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n\n    return this.page(href, trigger, self);\n  }\n\n  /**\n   * ### Start an \"once\" transition.\n   *\n   * If some registered \"once\" transition,\n   * get the \"resolved\" transition from the store and start it.\n   */\n  public async once(readyData: ITransitionData): Promise<void> {\n    await this.hooks.do('beforeEnter', readyData);\n\n    // Check if once transition\n    if (this.transitions.hasOnce) {\n      const transition = this.transitions.get(readyData, {\n        once: true,\n      }) as ITransitionOnce;\n\n      await this.transitions.doOnce({ transition, data: readyData });\n    }\n\n    await this.hooks.do('afterEnter', readyData);\n  }\n\n  /**\n   * ### Start a \"page\" transition.\n   *\n   * 1. If no running transition, updates data with full URL properties and trigger.\n   * 2. Get page from cache or init request.\n   * 3. Wait if some transitions need \"next\" data (`sync: true`, `to: `).\n   * 4. Manage the history, depending on trigger.\n   * 5. Get \"data\" and trigger \"go\" hook.\n   * 6. Get the \"resolved\" transition from the store and start it.\n   * 7. Update title and reset data (current, next = undefined).\n   *\n   * > If \"self\", use the \"self\" transition\n   */\n  public async page(\n    href: string,\n    trigger: Trigger,\n    self: boolean\n  ): Promise<void> {\n    this.data.next.url = {\n      href,\n      ...this.url.parse(href),\n    };\n    this.data.trigger = trigger;\n\n    const page = this.cache.has(href)\n      ? this.cache.update(href, { action: 'click' }).request\n      : this.cache.set(\n          href,\n          this.request(\n            href,\n            this.timeout,\n            this.onRequestError.bind(this, trigger)\n          ),\n          'click'\n        ).request;\n\n    // Need to wait before getting the right transition\n    if (this.transitions.shouldWait) {\n      await helpers.update(page, this.data);\n    }\n\n    const data = this.data;\n\n    // Hook: between trigger and transition\n    // Can be used to resolve \"route\"\n    await this.hooks.do('page', data);\n\n    try {\n      const transition = this.transitions.get(data, {\n        once: false,\n        self,\n      }) as ITransitionPage;\n\n      await this.transitions.doPage({\n        data,\n        page,\n        transition,\n        wrapper: this._wrapper,\n      });\n\n      this._resetData();\n    } catch (error) {\n      // Something went wrong (rejected promise, error, 404, 505, other)\n      // TODO: manage / use cases for cancellation\n      // this.logger.debug('Transition cancelled');\n\n      // If transition error and no debug mode, force reload page.\n      /* istanbul ignore else */\n      if (Logger.getLevel() === 0) {\n        this.force(data.current.url.href);\n      }\n    }\n  }\n\n  /**\n   * When a request error occurs.\n   *\n   * Allow the user to manage request error. (E.g: 404)\n   */\n  public onRequestError(trigger: Trigger, ...args: any): boolean {\n    // Cancel transition status\n    this.transitions.isRunning = false;\n\n    const [href, response]: [string, RequestErrorOrResponse] = args;\n    const action = this.cache.getAction(href);\n    this.cache.delete(href);\n\n    // Custom requestError returning false will return here.\n    if (\n      this._requestCustomError &&\n      this._requestCustomError(trigger, action, href, response) === false\n    ) {\n      return false;\n    }\n\n    // Force page change\n    if (action === 'click') {\n      this.force(href);\n    }\n    return false;\n  }\n\n  /**\n   * Programmatically prefetch\n   */\n  public prefetch(href: string) {\n    // Already in cache\n    /* istanbul ignore next */\n    if (this.cache.has(href)) {\n      return;\n    }\n\n    this.cache.set(\n      href,\n      this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, 'barba')\n      ).catch((error: RequestErrorOrResponse) => {\n        this.logger.error(error);\n      }),\n      'prefetch'\n    );\n  }\n\n  /**\n   * Bind event listeners.\n   */\n  private _bind(): void {\n    /* istanbul ignore else */\n    if (this.prefetchIgnore !== true) {\n      document.addEventListener('mouseover', this._onLinkEnter);\n      document.addEventListener('touchstart', this._onLinkEnter);\n    }\n    document.addEventListener('click', this._onLinkClick);\n    window.addEventListener('popstate', this._onStateChange);\n  }\n\n  /**\n   * Bind event listeners.\n   */\n  private _unbind(): void {\n    /* istanbul ignore else */\n    if (this.prefetchIgnore !== true) {\n      document.removeEventListener('mouseover', this._onLinkEnter);\n      document.removeEventListener('touchstart', this._onLinkEnter);\n    }\n    document.removeEventListener('click', this._onLinkClick);\n    window.removeEventListener('popstate', this._onStateChange);\n  }\n\n  /**\n   * When a element is entered.\n   *\n   * Get valid link element.\n   * Cache URL if needed.\n   */\n  private _onLinkEnter(e: LinkEvent): void {\n    const link = this._getLinkElement(e);\n\n    if (!link) {\n      return;\n    }\n\n    const href = this.dom.getHref(link);\n\n    if (this.prevent.checkHref(href)) {\n      return;\n    }\n\n    // Already in cache\n    if (this.cache.has(href)) {\n      return;\n    }\n\n    this.cache.set(\n      href,\n      this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, link)\n      ).catch((error: RequestErrorOrResponse) => {\n        this.logger.error(error);\n      }),\n      'enter'\n    );\n  }\n\n  /**\n   * When an element is clicked.\n   *\n   * Get valid link element.\n   * Prevent same URL.\n   * Go for a Barba transition.\n   */\n  private _onLinkClick(e: LinkEvent): void {\n    // This use `prevent.checkLink` under the hood to get eligible link.\n    const link = this._getLinkElement(e);\n\n    if (!link) {\n      return;\n    }\n\n    if (this.transitions.isRunning && this.preventRunning) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      return;\n    }\n\n    this.go(this.dom.getHref(link), link, e);\n  }\n\n  /**\n   * When History state changes.\n   *\n   * Get \"href\" from URL\n   * Go for a Barba transition.\n   */\n  private _onStateChange(e: PopStateEvent): void {\n    this.go(this.url.getHref(), 'popstate', e);\n  }\n\n  /**\n   * Get a valid link ancestor.\n   *\n   * Check for a \"href\" attribute.\n   * Then check if eligible for Barba.\n   */\n  private _getLinkElement(e: LinkEvent): Link {\n    let el = e.target as Link;\n\n    while (el && !this.dom.getHref(el)) {\n      el = (el as HTMLElement).parentNode as Link;\n    }\n\n    // Check prevent\n    if (!el || this.prevent.checkLink(el, e, this.dom.getHref(el))) {\n      return;\n    }\n\n    return el;\n  }\n\n  /**\n   * Reset pages data.\n   *\n   * Set \"current\" and unset \"next\".\n   */\n  private _resetData() {\n    const href = this.url.getHref();\n    const current = {\n      container: this.dom.getContainer(),\n      html: this.dom.getHtml(),\n      namespace: this.dom.getNamespace(),\n      url: {\n        href,\n        ...this.url.parse(href),\n      },\n    };\n\n    this._data = {\n      current,\n      next: { ...this.schemaPage },\n      trigger: undefined,\n    };\n\n    this.hooks.do('reset', this.data);\n  }\n}\n\nconst core = new Core();\n\nexport default core;\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/**\n * @barba/core/modules/Logger\n * <br><br>\n * ## Logger.\n *\n * - Display informations via the console\n *\n * @module core/modules/Logger\n * @preferred\n */\n\n/***/\n\n/**\n * Log levels, all lower level messages are printed\n *\n * 0. mute\n * 1. error = `console.error()`\n * 2. warning= `console.warn()`\n * 3. info = `console.info()`\n * 4. debug = `console.log()`\n */\nexport enum LogLevels {\n  off = 0,\n  error = 1,\n  warning = 2,\n  info = 3,\n  debug = 4,\n}\n\n/**\n * Global log level\n */\nlet _level: number = LogLevels.off;\n\nexport class Logger {\n  /**\n   * Get global log level.\n   */\n  public static getLevel(): number {\n    return _level;\n  }\n\n  /**\n   * Set global log level.\n   */\n  public static setLevel(name: keyof typeof LogLevels): number {\n    _level = LogLevels[name];\n\n    return _level;\n  }\n\n  /**\n   * Log \"prefix\".\n   */\n  private _source: string;\n\n  /**\n   * Creates an instance of Logger.\n   */\n  constructor(source: string) {\n    this._source = source;\n  }\n\n  /**\n   * Permanent, unremovable log.\n   */\n  // public print(...objects: any[]): void {\n  //   this._log(console.info, LogLevels.off, objects);\n  // }\n\n  /**\n   * Error log.\n   */\n  public error(...objects: any[]): void {\n    this._log(console.error, LogLevels.error, objects);\n  }\n\n  /**\n   * Warn log.\n   */\n  public warn(...objects: any[]): void {\n    this._log(console.warn, LogLevels.warning, objects);\n  }\n\n  /**\n   * Info log.\n   */\n  public info(...objects: any[]): void {\n    this._log(console.info, LogLevels.info, objects);\n  }\n\n  /**\n   * Debug log.\n   */\n  public debug(...objects: any[]): void {\n    this._log(console.log, LogLevels.debug, objects);\n  }\n\n  /**\n   * Internal logger.\n   */\n  private _log(fn: () => void, level: number, objects: any[]): void {\n    if (level <= Logger.getLevel()) {\n      fn.apply(console, ([`[${this._source}] `].concat(objects) as unknown) as [\n\n      ]);\n    }\n  }\n}\n","/**\n * @module typings/core\n */\nimport { ITransitionData, ITransitionPage, IViewData } from './index';\n\nexport type HooksBarba =\n  | 'ready'\n  | 'page'\n  | 'reset'\n  | 'currentAdded'\n  | 'currentRemoved'\n  | 'nextAdded'\n  | 'nextRemoved';\n\nexport type HooksOnce = 'beforeOnce' | 'once' | 'afterOnce';\n\nexport type HooksPage =\n  | 'before'\n  | 'beforeLeave'\n  | 'leave'\n  | 'afterLeave'\n  | 'beforeEnter'\n  | 'enter'\n  | 'afterEnter'\n  | 'after';\n\nexport type HooksBefore = 'beforeOnce' | 'beforeLeave' | 'beforeEnter';\nexport type HooksAfter = 'afterOnce' | 'afterLeave' | 'afterEnter';\n\nexport type HooksTransition = HooksOnce | HooksPage;\nexport type HooksView = HooksBefore | HooksAfter;\nexport type HooksAll = HooksBarba | HooksTransition;\n\n// Allow optional \"dynamically created\" hooks\nexport type HooksTransitionMap = { [key in HooksTransition]?: any };\n\nexport type HookFunction = (\n  data?: ITransitionData | IViewData,\n  t?: ITransitionPage\n) => Promise<void> | void;\n\nexport class HookMethods {\n  public before: (fn: HookFunction, ctx?: any) => void;\n  public beforeLeave: (fn: HookFunction, ctx?: any) => void;\n  public leave: (fn: HookFunction, ctx?: any) => void;\n  public afterLeave: (fn: HookFunction, ctx?: any) => void;\n  public beforeEnter: (fn: HookFunction, ctx?: any) => void;\n  public enter: (fn: HookFunction, ctx?: any) => void;\n  public afterEnter: (fn: HookFunction, ctx?: any) => void;\n  public after: (fn: HookFunction, ctx?: any) => void;\n}\n","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.match = match\nmodule.exports.regexpToFunction = regexpToFunction\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var whitelist = (options && options.whitelist) || undefined\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n      var c = path[k]\n      var matches = whitelist ? whitelist.indexOf(c) > -1 : true\n\n      if (matches) {\n        prev = c\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var pattern = capture || group\n    var delimiter = prev || defaultDelimiter\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: pattern\n        ? escapeGroup(pattern)\n        : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options), options)\n}\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match (str, options) {\n  var keys = []\n  var re = pathToRegexp(str, keys, options)\n  return regexpToFunction(re, keys)\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction (re, keys) {\n  return function (pathname, options) {\n    var m = re.exec(pathname)\n    if (!m) return false\n\n    var path = m[0]\n    var index = m.index\n    var params = {}\n    var decode = (options && options.decode) || decodeURIComponent\n\n    for (var i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue\n\n      var key = keys[i - 1]\n\n      if (key.repeat) {\n        params[key.name] = m[i].split(key.delimiter).map(function (value) {\n          return decode(value, key)\n        })\n      } else {\n        params[key.name] = decode(m[i], key)\n      }\n    }\n\n    return { path: path, index: index, params: params }\n  }\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens, options) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n    var validate = options ? options.validate !== false : true\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) continue\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var start = options.start !== false\n  var end = options.end !== false\n  var delimiter = options.delimiter || DEFAULT_DELIMITER\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = start ? '^' : ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (!token.prefix) {\n          route += '(' + capture + ')?'\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + escapeString(delimiter) + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    var endToken = tokens[tokens.length - 1]\n    var isEndDelimited = typeof endToken === 'string'\n      ? endToken[endToken.length - 1] === delimiter\n      : endToken === undefined\n\n    if (!strict) route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')'\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","/**\n * @barba/core/schemas\n * <br><br>\n * ## Schemas description.\n *\n * @module core/schemas\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { ISchemaAttribute } from '../defs';\n\n/**\n * See [[ISchemaAttribute]]\n */\nexport const schemaAttribute: ISchemaAttribute = {\n  container: 'container',\n  history: 'history',\n  namespace: 'namespace',\n  prefix: 'data-barba',\n  prevent: 'prevent',\n  wrapper: 'wrapper',\n};\n","/**\n * @barba/core/utils/dom\n * <br><br>\n * ## Dom utils\n *\n * - Access DOM contents\n * - DOM vs string conversions\n *\n * @module core/utils/dom\n * @preferred\n */\n\n/***/\n\nimport path from 'path';\n\n// Definitions\nimport { ISchemaAttribute, Link, Scope, Wrapper } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n\nexport class Dom {\n  private _attr: ISchemaAttribute = schemaAttribute;\n  private _parser: DOMParser = new DOMParser();\n\n  /**\n   * Convert HTMLDocument to string.\n   */\n  public toString(el: HTMLElement): string {\n    return el.outerHTML;\n  }\n\n  /**\n   * Parse HTML string to HTMLDocument.\n   */\n  // see https://github.com/barbajs/barba/issues/362\n  // Seems that using DOMParser.parseFromString causes this issue.\n  public toDocument(htmlString: string): HTMLDocument {\n    return this._parser.parseFromString(htmlString, 'text/html');\n  }\n\n  /**\n   * Parse HTML string to DIVElement.\n   *\n   * DOMParser.parseFromString fails with img[srcset] on iOS.\n   * see https://github.com/barbajs/barba/issues/362\n   */\n  public toElement(htmlString: string): HTMLDivElement {\n    const div = document.createElement('div');\n\n    div.innerHTML = htmlString;\n    return div;\n  }\n\n  /**\n   * Get HTML content.\n   */\n  public getHtml(doc: HTMLDocument = document): string {\n    return this.toString(doc.documentElement);\n  }\n\n  /**\n   * Get full document content.\n   */\n  // getDocument(el = document.documentElement) {\n  //   return this.toStr(el);\n  // },\n\n  /**\n   * Get `[data-barba=\"wrapper\"]`.\n   */\n  public getWrapper(scope: Scope = document): Wrapper {\n    return scope.querySelector(\n      `[${this._attr.prefix}=\"${this._attr.wrapper}\"]`\n    );\n  }\n\n  /**\n   * Get `[data-barba=\"container\"]`.\n   */\n  public getContainer(scope: Scope = document): HTMLElement | null {\n    return scope.querySelector(\n      `[${this._attr.prefix}=\"${this._attr.container}\"]`\n    );\n  }\n\n  /**\n   * Remove container and store next sibling (if applicable).\n   */\n  public removeContainer(container: HTMLElement) {\n    if (document.body.contains(container)) {\n      container.parentNode.removeChild(container);\n    }\n  }\n\n  /**\n   * Add container before next sibling or at the end of the wrapper.\n   */\n  public addContainer(container: HTMLElement, wrapper: HTMLElement) {\n    const existingContainer = this.getContainer();\n\n    if (existingContainer) {\n      this._insertAfter(container, existingContainer);\n    } else {\n      wrapper.appendChild(container);\n    }\n  }\n\n  /**\n   * Get `[data-barba-namespace]`.\n   */\n  public getNamespace(scope: Scope = document): string | null {\n    const ns = scope.querySelector(\n      `[${this._attr.prefix}-${this._attr.namespace}]`\n    );\n\n    return ns\n      ? ns.getAttribute(`${this._attr.prefix}-${this._attr.namespace}`)\n      : null;\n  }\n\n  /**\n   * Get URL from `href` value.\n   */\n  public getHref(el: Link): string | null {\n    // HTML tagName is UPPERCASE, xhtml tagName keeps existing case.\n    if (el.tagName && el.tagName.toLowerCase() === 'a') {\n      // HTMLAnchorElement, full URL available\n      if (typeof el.href === 'string') {\n        return el.href;\n      }\n\n      // Probably a SVGAElement\n      const href = el.getAttribute('href') || el.getAttribute('xlink:href');\n\n      /* istanbul ignore else */\n      if (href) {\n        // When link comes from SVG, `href` returns an object, not a string.\n        const attr: string =\n          ((href as unknown) as SVGAnimatedString).baseVal || href;\n\n        return this.resolveUrl(attr);\n      }\n    }\n    return null;\n  }\n\n  // Copyright 2014 Simon Lydell\n  // X11 (MIT) Licensed. (See LICENSE\n  // https://github.com/lydell/resolve-url/blob/master/resolve-url.js\n  /* istanbul ignore next */\n  public resolveUrl(...urls: string[]) {\n    const numUrls = urls.length;\n\n    if (numUrls === 0) {\n      throw new Error('resolveUrl requires at least one argument; got none.');\n    }\n\n    const base = document.createElement('base');\n    base.href = arguments[0];\n\n    if (numUrls === 1) {\n      return base.href;\n    }\n\n    const head = document.getElementsByTagName('head')[0];\n    head.insertBefore(base, head.firstChild);\n\n    const a = document.createElement('a');\n    let resolved;\n\n    for (let index = 1; index < numUrls; index++) {\n      a.href = arguments[index];\n      resolved = a.href;\n      base.href = resolved;\n    }\n\n    head.removeChild(base);\n\n    return resolved;\n  }\n\n  /**\n   * Insert node after another node.\n   */\n  private _insertAfter(newNode: Node, referenceNode: Node) {\n    referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n  }\n}\n\nconst dom = new Dom();\n\nexport { dom };\n","import { HistoryAction, LinkEvent, Trigger } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n\n/**\n * @barba/core/utils/history\n * <br><br>\n * ## History manager.\n *\n * - Keep track of the navigation history\n *\n * @module core/utils/history\n * @preferred\n */\n\n/**\n * State item.\n *\n * @property from\n * @property index\n */\ninterface IHistoryItem {\n  /** origin */\n  from: string;\n  /** index */\n  index: number;\n  /** states */\n  states: IStateItem[];\n}\n\n/***/\ninterface ICoords {\n  x: number;\n  y: number;\n}\n\n/**\n * History item.\n *\n * @property namespace\n * @property scroll\n * @property URL\n */\ninterface IStateItem {\n  /** namespace */\n  ns: string | undefined;\n  /** Scroll position */\n  scroll: ICoords;\n  /** URL */\n  url: string;\n}\n\nexport class History {\n  private _session: string;\n  private _states: IStateItem[] = [];\n  private _pointer = -1;\n\n  /**\n   * Init with first state.\n   */\n  public init(url: string, ns: string): void {\n    this._session = 'barba';\n    const index = 0;\n\n    const state: IStateItem = {\n      ns,\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY,\n      },\n      url,\n    };\n\n    this._states.push(state);\n    this._pointer = index;\n\n    const item: IHistoryItem = {\n      from: this._session,\n      index,\n      states: [...this._states],\n    };\n\n    window.history && window.history.replaceState(item, '', url);\n  }\n\n  public change(\n    url: string,\n    trigger: Trigger,\n    e?: LinkEvent | PopStateEvent\n  ): Trigger {\n    if (e && (e as PopStateEvent).state) {\n      // If popstate, move to existing state\n      // and get back/forward direction.\n      const { state }: { state: IHistoryItem } = e as PopStateEvent;\n      const { index } = state;\n      const diff = this._pointer - index;\n\n      trigger = this._getDirection(diff);\n\n      // Work with previous states\n      this.replace(state.states);\n      this._pointer = index;\n    } else {\n      // Add new state\n      this.add(url, trigger);\n    }\n\n    return trigger;\n  }\n\n  /**\n   * Add a new state.\n   */\n  public add(url: string, trigger: Trigger): void {\n    // If no state, it will be updated later.\n    const ns = 'tmp';\n    const index = this.size;\n    const action = this._getAction(trigger);\n    const state: IStateItem = {\n      ns,\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY,\n      },\n      url,\n    };\n\n    this._states.push(state);\n    this._pointer = index;\n\n    const item: IHistoryItem = {\n      from: this._session,\n      index,\n      states: [...this._states],\n    };\n\n    switch (action) {\n      case 'push':\n        window.history && window.history.pushState(item, '', url);\n        break;\n      case 'replace':\n        window.history && window.history.replaceState(item, '', url);\n        break;\n      /* istanbul ignore next */\n      default:\n    }\n  }\n\n  /**\n   * Update state.\n   */\n  public update(data: any, i?: number): void {\n    const index = i || this._pointer;\n    const existing = this.get(index);\n    const state: IStateItem = {\n      ...existing,\n      ...data,\n    };\n\n    this.set(index, state);\n  }\n\n  /**\n   * Remove last state.\n   */\n  public remove(i?: number): void {\n    if (i) {\n      this._states.splice(i, 1);\n    } else {\n      this._states.pop();\n    }\n\n    this._pointer--;\n  }\n\n  /**\n   * Delete all states.\n   */\n  public clear(): void {\n    this._states = [];\n    this._pointer = -1;\n  }\n\n  /**\n   * Replace all states.\n   */\n  public replace(newStates: IStateItem[]): void {\n    this._states = newStates;\n  }\n\n  /**\n   * Get state by index.\n   */\n  public get(index: number) {\n    return this._states[index];\n  }\n\n  /**\n   * Set state by index.\n   */\n  public set(i: number, state: IStateItem) {\n    return (this._states[i] = state);\n  }\n\n  /**\n   * Get the current state.\n   */\n  get current(): IStateItem {\n    return this._states[this._pointer];\n  }\n\n  /**\n   * Get the last state (top of the history stack).\n   */\n  get state(): IStateItem {\n    return this._states[this._states.length - 1];\n  }\n\n  /**\n   * Get the previous state.\n   */\n  get previous(): IStateItem | null {\n    return this._pointer < 1 ? null : this._states[this._pointer - 1];\n  }\n\n  /**\n   * Get the state size.\n   */\n  get size(): number {\n    return this._states.length;\n  }\n\n  /**\n   * Get the history action: push vs replace\n   */\n  private _getAction(trigger: Trigger): HistoryAction {\n    let action: HistoryAction = 'push';\n\n    // Manage `data-barba-history` attribute\n    // to get the right action (push vs replace).\n    const el = trigger as HTMLAnchorElement;\n    const attr = `${schemaAttribute.prefix}-${schemaAttribute.history}`;\n\n    if (el.hasAttribute && el.hasAttribute(attr)) {\n      action = el.getAttribute(attr) as HistoryAction;\n    }\n\n    return action;\n  }\n\n  /**\n   * Get the direction of popstate change\n   */\n  private _getDirection(diff: number): Trigger {\n    // Check if \"session switch\"\n    if (Math.abs(diff) > 1) {\n      // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\n      return diff > 0 ? 'forward' : 'back';\n    } else {\n      if (diff === 0) {\n        return 'popstate';\n      } else {\n        // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\n        return diff > 0 ? 'back' : 'forward';\n      }\n    }\n  }\n}\n\nconst history = new History();\n\nexport { history };\n","/**\n * @barba/core/utils/helpers\n * <br><br>\n * ## Helpers\n *\n * - Update next page data\n *\n * @module core/utils/helpers\n * @preferred\n */\n\n/***/\n\n// Third-party\nimport ptr from 'path-to-regexp';\n// Definitions\nimport { ITransitionData } from '../defs';\n// Utils\nimport { dom } from './dom';\nimport { history } from './history';\n\n/**\n * Update `data.next`, the title and the history\n */\nexport const update = async (\n  page: Promise<string | void>,\n  data: ITransitionData\n): Promise<void> => {\n  // If not already updated\n  if (!data.next.html) {\n    const html = await page;\n    const { next } = data;\n\n    if (html) {\n      // see: https://github.com/barbajs/barba/issues/362\n      // const nextDocument = dom.toDocument(html);\n      const nextDocument = dom.toElement(html);\n\n      next.namespace = dom.getNamespace(nextDocument);\n      next.container = dom.getContainer(nextDocument);\n      // see https://github.com/barbajs/barba/issues/362\n      // next.html = dom.getHtml(nextDocument);\n      // next.html = nextDocument.innerHTML;\n      next.html = html;\n\n      // Update history namespace (not available when initially set)\n      history.update({ ns: next.namespace });\n\n      // Update title.\n      const { title } = dom.toDocument(html);\n\n      document.title = title;\n    }\n  }\n};\n\n/**\n * Next tick\n */\nexport const nextTick = () =>\n  new Promise(resolve => {\n    window.requestAnimationFrame(resolve);\n    // DEV: same result?\n    // setTimeout(resolve, 0);\n  });\n\n/**\n * Turn a route string such as `/user/:name` into a regular expression.\n *\n * Used for:\n *\n * - routes to ignore\n * - route transition resolution\n *\n * @see https://www.npmjs.com/package/path-to-regexp\n */\nconst pathToRegexp = ptr;\n\nexport { pathToRegexp };\n","/**\n * @barba/core/utils/url\n * <br><br>\n * ## URL utils.\n *\n * - Collect and structure informations from URLs\n *\n * @module core/utils/url\n */\n\n/***/\n\n// Definitions\nimport { IGenericObject, IUrlBase } from '../defs';\n\n/**\n * Get location href.\n */\nexport const getHref = () => window.location.href;\n\n/**\n * Get location origin.\n */\nexport const getOrigin = () => window.location.origin;\n\n/**\n * Get port based on URL or location.\n */\nexport const getPort = (url: string = window.location.href) => parse(url).port;\n\n/**\n * Get path from URL.\n */\nexport const getPath = (url: string = window.location.href) => parse(url).path;\n\n/**\n * Get query object from URL.\n */\n// export const getQuery = (url: string): IGenericObject => parse(url).query;\n\n/**\n * Get hash from URL.\n */\n// export const getHash = (url: string): string => parse(url).hash;\n\n/**\n * Parse URL for path, query and hash and more.\n */\nexport const parse = (url: string): IUrlBase => {\n  // Port\n  let port;\n  const matches = url.match(/:\\d+/);\n\n  if (matches === null) {\n    if (/^http/.test(url)) {\n      port = 80;\n    }\n\n    if (/^https/.test(url)) {\n      port = 443;\n    }\n  } else {\n    const portString = matches[0].substring(1);\n\n    port = parseInt(portString, 10);\n  }\n\n  // Path\n  let path = url.replace(getOrigin(), '');\n  let hash;\n  let query = {};\n\n  // Hash\n  const hashIndex = path.indexOf('#');\n\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex + 1);\n    path = path.slice(0, hashIndex);\n  }\n\n  // Query\n  const queryIndex = path.indexOf('?');\n\n  if (queryIndex >= 0) {\n    query = parseQuery(path.slice(queryIndex + 1));\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    hash,\n    path,\n    port,\n    query,\n  };\n};\n\n/**\n * Parse a query string to object.\n */\nexport const parseQuery = (str: string) =>\n  str.split('&').reduce((acc: IGenericObject, el: string) => {\n    const [key, value] = el.split('=');\n\n    acc[key] = value;\n\n    return acc;\n  }, {});\n\n/**\n * Clean URL, remove \"hash\" and/or \"trailing slash\".\n */\nexport const clean = (url: string = window.location.href) =>\n  url.replace(/(\\/#.*|\\/|#.*)$/, '');\n","/**\n * @barba/core/utils/request\n * <br><br>\n * ## Fetch pages for transitions.\n *\n * - Includes timeout\n * - Uses Fetch API\n * - Handles errors\n *\n * @module core/utils/request\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { RequestError } from '../defs';\n\n/**\n * Init a page request.\n * Fetch the page and returns a promise with the text content.\n */\nfunction request(\n  url: string,\n  ttl: number = 2e3,\n  requestError: RequestError\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        if (xhr.status === 200) {\n          resolve(xhr.responseText);\n        } else if (xhr.status) {\n          // HTTP code is not 200, reject with response.\n          const res = {\n            status: xhr.status,\n            statusText: xhr.statusText,\n          };\n          requestError(url, res);\n          reject(res);\n        }\n      }\n    };\n    xhr.ontimeout = () => {\n      const err = new Error(`Timeout error [${ttl}]`);\n      requestError(url, err);\n      reject(err);\n    };\n    xhr.onerror = () => {\n      const err = new Error(`Fetch error`);\n      requestError(url, err);\n      reject(err);\n    };\n\n    xhr.open('GET', url);\n    xhr.timeout = ttl;\n    xhr.setRequestHeader(\n      'Accept',\n      'text/html,application/xhtml+xml,application/xml'\n    );\n    xhr.setRequestHeader('x-barba', 'yes');\n    xhr.send();\n  });\n}\n\nexport { request };\n","module.exports = isPromise;\n\nfunction isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n","import isPromise from 'is-promise';\n\n// https://github.com/SBoudrias/run-async\n/* istanbul ignore next */\nexport function runAsync(\n  func: (...args: any[]) => void | Promise<any>,\n  ctx: any = {}\n): (...args: any[]) => Promise<any> {\n  return (...args: any[]) => {\n    let async = false;\n\n    const promise = new Promise((resolve, reject) => {\n      // Add async to context\n      ctx.async = () => {\n        async = true;\n\n        return (err: any, value: any) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(value);\n          }\n        };\n      };\n\n      const answer = func.apply(ctx, args as []);\n\n      if (!async) {\n        if (isPromise(answer)) {\n          (answer as Promise<any>).then(resolve, reject);\n        } else {\n          resolve(answer);\n        }\n      }\n    });\n\n    return promise;\n  };\n}\n","/**\n * @barba/core/modules/hooks\n * <br><br>\n * ## Hooks manager.\n *\n * - Register and trigger hooks\n *\n * Hooks can be easily registered:\n *\n * ```js\n * hooks.leave(callback, context);\n * ```\n *\n * @module core/modules/hooks\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HookFunction, HookMethods, HooksAll } from './defs';\n// Modules\nimport { Logger } from './modules/Logger';\n// Utils\nimport { runAsync } from './utils';\n// Types\ninterface IHookInfos {\n  ctx: any;\n  fn: HookFunction;\n}\n\nexport class Hooks extends HookMethods {\n  /**\n   * Allow the use of `hooks[name](cb, ctx)`.\n   */\n  [key: string]: any;\n  // [key in HooksAll]?: any;\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * All available hooks.\n   *\n   * See [[HooksAll]]\n   */\n  // TODO: get hooks from defs (DRY)?\n  public all: HooksAll[] = [\n    'ready',\n    'page',\n    'reset',\n    'currentAdded',\n    'currentRemoved',\n    'nextAdded',\n    'nextRemoved',\n    'beforeOnce',\n    'once',\n    'afterOnce',\n    'before',\n    'beforeLeave',\n    'leave',\n    'afterLeave',\n    'beforeEnter',\n    'enter',\n    'afterEnter',\n    'after',\n  ];\n  /**\n   * Registered hooks.\n   *\n   * - Unique hook name\n   * - Associated data set(s) (callback + context)\n   */\n  public registered: Map<HooksAll, Set<IHookInfos>> = new Map();\n\n  constructor() {\n    super();\n    this.init();\n  }\n\n  public init() {\n    this.registered.clear();\n    this.all.forEach(hook => {\n      if (!this[hook]) {\n        this[hook] = (fn: HookFunction, ctx?: any) => {\n          if (!this.registered.has(hook)) {\n            this.registered.set(hook, new Set());\n          }\n          const set = this.registered.get(hook);\n\n          set.add({\n            ctx: ctx || {},\n            fn,\n          });\n        };\n      }\n    });\n  }\n\n  /**\n   * Do hook.\n   *\n   * Trigger registered hooks.\n   */\n  public do(name: HooksAll, ...args: any): Promise<any> {\n    if (this.registered.has(name)) {\n      // Let's start a chain of promises\n      let chain = Promise.resolve();\n\n      this.registered.get(name).forEach(hook => {\n        // Chain async hooks promisified\n        chain = chain.then(() => runAsync(hook.fn, hook.ctx)(...args));\n      });\n\n      return chain.catch(error => {\n        this.logger.debug(`Hook error [${name}]`);\n        this.logger.error(error);\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  public clear(): void {\n    this.all.forEach(hook => {\n      delete this[hook];\n    });\n\n    this.init();\n  }\n\n  /**\n   * Help, print available and registered hooks.\n   */\n  public help(): void {\n    this.logger.info(`Available hooks: ${this.all.join(',')}`);\n    const registered: string[] = [];\n    this.registered.forEach((value, key) => registered.push(key));\n    this.logger.info(`Registered hooks: ${registered.join(',')}`);\n  }\n}\n\nconst hooks = new Hooks();\n\nexport { hooks };\n","/**\n * @barba/core/modules/ignore\n * <br><br>\n * ## Manage ignore options.\n *\n * - cache\n * - prefetch\n *\n * @module core/modules/ignore\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { IgnoreOption } from '../defs';\n// Utils\nimport { pathToRegexp } from '../utils/helpers';\nimport { parse } from '../utils/url';\n\nexport class Ignore {\n  private _ignoreAll: boolean;\n  private _ignoreRegexes: RegExp[] = [];\n\n  constructor(ignore: IgnoreOption) {\n    if (typeof ignore === 'boolean') {\n      this._ignoreAll = ignore;\n    } else {\n      const paths = Array.isArray(ignore) ? ignore : [ignore];\n\n      this._ignoreRegexes = paths.map(p => pathToRegexp(p));\n    }\n  }\n\n  public checkHref(href: string): boolean {\n    if (typeof this._ignoreAll === 'boolean') {\n      return this._ignoreAll;\n    }\n\n    const { path } = parse(href);\n\n    return this._ignoreRegexes.some(regex => regex.exec(path) !== null);\n  }\n}\n","/**\n * @barba/core/modules/cache\n * <br><br>\n * ## Cache for storing URL / HTML.\n *\n * @module core/modules/cache\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { CacheAction, CacheRequest, ICacheData, IgnoreOption } from '../defs';\n// Modules\nimport { Ignore } from './Ignore';\n\nexport class Cache extends Ignore {\n  private _state: Map<string, ICacheData> = new Map();\n\n  constructor(ignore: IgnoreOption) {\n    super(ignore);\n  }\n\n  /**\n   * Set value to cache\n   */\n  public set(\n    href: string,\n    request: CacheRequest,\n    action: CacheAction\n  ): ICacheData {\n    this._state.set(href, {\n      action,\n      request,\n    });\n\n    return {\n      action,\n      request,\n    };\n  }\n\n  /**\n   * Get data from cache\n   */\n  public get(href: string): ICacheData {\n    return this._state.get(href);\n  }\n\n  /**\n   * Get request from cache\n   */\n  public getRequest(href: string): CacheRequest {\n    return this._state.get(href).request;\n  }\n\n  /**\n   * Get action from cache\n   */\n  public getAction(href: string): CacheAction {\n    return this._state.get(href).action;\n  }\n\n  /**\n   * Check if value exists into cache\n   */\n  public has(href: string): boolean {\n    /* istanbul ignore else */\n    if (this.checkHref(href)) {\n      return false;\n    }\n    return this._state.has(href);\n  }\n\n  /**\n   * Delete value from cache\n   */\n  public delete(href: string): boolean {\n    return this._state.delete(href);\n  }\n\n  /**\n   * Update cache value\n   */\n  public update(href: string, data: ICacheData): ICacheData {\n    const state = {\n      ...this._state.get(href),\n      ...data,\n    };\n    this._state.set(href, state);\n\n    return state;\n  }\n}\n","/**\n * @barba/core/modules/prevent\n * <br><br>\n * ## Prevent checks.\n *\n * - Gathers all the tests that allow Barba to work and play transitions\n *\n * @module core/modules/prevent\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { IgnoreOption, Link, PreventCheck } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n// Utils\nimport { url } from '../utils';\n// Modules\nimport { Ignore } from './Ignore';\n\n/**\n * Make sure the browser supports `history.pushState`.\n */\nconst pushState: PreventCheck = () => !window.history.pushState;\n\n/**\n * Make sure there is an `el` and `href`.\n */\nconst exists: PreventCheck = ({ el, href }) => !el || !href;\n\n/**\n * If the user is pressing ctrl + click, the browser will open a new tab.\n */\nconst newTab: PreventCheck = ({ event }) =>\n  (event as KeyboardEvent).which > 1 ||\n  (event as KeyboardEvent).metaKey ||\n  (event as KeyboardEvent).ctrlKey ||\n  (event as KeyboardEvent).shiftKey ||\n  (event as KeyboardEvent).altKey;\n\n/**\n * If the link has `_blank` target.\n */\nconst blank: PreventCheck = ({ el }) =>\n  el.hasAttribute('target') && (el as Link).target === '_blank';\n\n/**\n * If the domain is the same (in order to avoid pushState cross origin security problem).\n * Note: SVGAElement do not have `protocol` neither `hostname` properties.\n */\nconst corsDomain: PreventCheck = ({ el }) =>\n  ((el as HTMLAnchorElement).protocol !== undefined &&\n    window.location.protocol !== (el as HTMLAnchorElement).protocol) ||\n  ((el as HTMLAnchorElement).hostname !== undefined &&\n    window.location.hostname !== (el as HTMLAnchorElement).hostname);\n\n/**\n * If the port is the same.\n * Note: SVGAElement do not have `port` property.\n */\nconst corsPort: PreventCheck = ({ el }) =>\n  (el as HTMLAnchorElement).port !== undefined &&\n  url.getPort() !== url.getPort((el as HTMLAnchorElement).href);\n\n/**\n * If the link has download attribute.\n */\nconst download: PreventCheck = ({ el }) =>\n  el.getAttribute && typeof el.getAttribute('download') === 'string';\n\n/**\n * If the links contains [data-barba-prevent] or [data-barba-prevent=\"self\"].\n */\nconst preventSelf: PreventCheck = ({ el }) =>\n  el.hasAttribute(`${schemaAttribute.prefix}-${schemaAttribute.prevent}`);\n\n/**\n * If some link ancestor contains [data-barba-prevent=\"all\"].\n */\nconst preventAll: PreventCheck = ({ el }) =>\n  Boolean(\n    el.closest(`[${schemaAttribute.prefix}-${schemaAttribute.prevent}=\"all\"]`)\n  );\n\n/**\n * If the link is the current URL.\n *\n * > Not in the test suite.\n */\nconst sameUrl: PreventCheck = ({ href }) =>\n  url.clean(href) === url.clean() && url.getPort(href) === url.getPort();\n\nexport class Prevent extends Ignore {\n  public suite: string[] = [];\n  public tests: Map<string, PreventCheck> = new Map();\n\n  constructor(ignore: IgnoreOption) {\n    super(ignore);\n    this.init();\n  }\n\n  public init(): void {\n    // Add defaults\n    this.add('pushState', pushState);\n    this.add('exists', exists);\n    this.add('newTab', newTab);\n    this.add('blank', blank);\n    this.add('corsDomain', corsDomain);\n    this.add('corsPort', corsPort);\n    this.add('download', download);\n    this.add('preventSelf', preventSelf);\n    this.add('preventAll', preventAll);\n\n    // Outside of the test suite\n    this.add('sameUrl', sameUrl, false);\n  }\n\n  public add(name: string, check: PreventCheck, suite: boolean = true): void {\n    this.tests.set(name, check);\n    suite && this.suite.push(name);\n  }\n\n  /**\n   * Run individual test\n   */\n  public run(name: string, el: Link, event: Event, href: string): boolean {\n    return this.tests.get(name)({\n      el,\n      event,\n      href,\n    });\n  }\n\n  /**\n   * Run test suite\n   */\n  public checkLink(el: Link, event: Event, href: string): boolean {\n    return this.suite.some(name => this.run(name, el, event, href));\n  }\n}\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class BarbaError extends Error {\n  /* istanbul ignore next */\n  constructor(\n    public error: Error,\n    public label = 'Barba error',\n    ...params: any[]\n  ) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(...params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    /* istanbul ignore else */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, BarbaError);\n    }\n\n    this.name = 'BarbaError';\n  }\n}\n","/**\n * @barba/core/modules/store\n * <br><br>\n * ## Transitions store.\n *\n * - Resolve transition\n * - Manage rules\n *\n * @module core/modules/store\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport {\n  IRule,\n  IRules,\n  ITransitionData,\n  ITransitionFilters,\n  ITransitionOnce,\n  ITransitionPage,\n  RuleName,\n} from '../defs';\n\n// Modules\nimport { Logger } from './Logger';\n\nexport class Store {\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * All registered transitions.\n   */\n  public all: ITransitionPage[] = [];\n  /**\n   * \"Page only\" registered transitions.\n   */\n  public page: ITransitionPage[] = [];\n  /**\n   * \"Once only\" registered transitions.\n   */\n  public once: ITransitionOnce[] = [];\n  /**\n   * Rules for transition resolution.\n   *\n   * Defaults:\n   *\n   * - namespace\n   * - custom\n   */\n  private _rules: IRule[] = [\n    {\n      name: 'namespace',\n      type: 'strings',\n    },\n    {\n      name: 'custom',\n      type: 'function',\n    },\n  ];\n\n  /**\n   * Init store.\n   */\n  constructor(transitions: ITransitionPage[] = []) {\n    /* istanbul ignore else */\n    if (transitions) {\n      // TODO: add check for valid transitions? criteria? (once || enter && leave)\n      this.all = this.all.concat(transitions);\n    }\n    this.update();\n  }\n\n  /**\n   * Add rule or transition.\n   */\n  public add(type: 'rule' | 'transition', data: any): void {\n    switch (type) {\n      case 'rule':\n        // TODO: check for valid rule\n        this._rules.splice(data.position || 0, 0, data.value);\n        break;\n      case 'transition':\n      default:\n        // TODO: check for valid transition\n        this.all.push(data);\n        break;\n    }\n\n    this.update();\n  }\n\n  /**\n   * Resolve transition.\n   */\n  public resolve(\n    data: ITransitionData,\n    filters: ITransitionFilters = {}\n  ): ITransitionOnce | ITransitionPage {\n    // Filter on \"once\"\n    let transitions = filters.once ? this.once : this.page;\n\n    // Filter on \"self\"\n    if (filters.self) {\n      transitions = transitions.filter(t => t.name && t.name === 'self');\n    } else {\n      transitions = transitions.filter(t => !t.name || t.name !== 'self');\n    }\n\n    // All matching transition infos\n    const matching = new Map();\n\n    // Active = first of valid transitions\n    // sorted by directions (from/to, from || to, )\n    const active = transitions.find(t => {\n      let valid = true;\n      const match = {};\n\n      if (filters.self && t.name === 'self') {\n        return true;\n      }\n\n      // Check rules\n      this._rules.reverse().forEach(rule => {\n        if (valid) {\n          valid = this._check(t, rule, data, match);\n          // From/to check\n          if (t.from && t.to) {\n            valid =\n              this._check(t, rule, data, match, 'from') &&\n              this._check(t, rule, data, match, 'to');\n          }\n          if (t.from && !t.to) {\n            valid = this._check(t, rule, data, match, 'from');\n          }\n          if (!t.from && t.to) {\n            valid = this._check(t, rule, data, match, 'to');\n          }\n        }\n      });\n\n      matching.set(t, match);\n\n      return valid;\n    });\n\n    const activeMatch = matching.get(active);\n    const transitionType = [];\n    if (filters.once) {\n      transitionType.push('once');\n    } else {\n      transitionType.push('page');\n    }\n    if (filters.self) {\n      transitionType.push('self');\n    }\n\n    if (activeMatch) {\n      // Log resolved transition\n      const infos: any[] = [active];\n      // Log if matching criteria\n      Object.keys(activeMatch).length > 0 && infos.push(activeMatch);\n\n      this.logger.info(\n        `Transition found [${transitionType.join(',')}]`,\n        ...infos\n      );\n    } else {\n      this.logger.info(`No transition found [${transitionType.join(',')}]`);\n    }\n\n    return active;\n  }\n\n  /**\n   * ### Update store.\n   *\n   * - Reorder transition by priorities\n   * - Get wait indicator\n   * - Get once transitions\n   */\n  public update(): void {\n    // Reorder by priorities\n    this.all = this.all\n      .map(t => this._addPriority(t))\n      .sort((a, b) => a.priority - b.priority)\n      .reverse()\n      .map(t => {\n        delete t.priority;\n\n        return t;\n      });\n    this.page = this.all.filter(\n      t => t.leave !== undefined || t.enter !== undefined\n    ) as ITransitionPage[];\n    this.once = this.all.filter(t => t.once !== undefined) as ITransitionOnce[];\n  }\n\n  /**\n   * ### Check if transition apply.\n   *\n   * Based on rule, page data and optional direction:\n   *\n   * 1. transition has no rule \"property\":\n   *    - always returns true\n   * 2. transition has rule \"property\":\n   *     - \"strings\" should be present on both side (transition + page) and match\n   *     - \"function\" should return true\n   */\n  private _check(\n    transition: ITransitionPage,\n    rule: IRule,\n    data: ITransitionData,\n    match: any,\n    direction?: 'from' | 'to'\n  ): boolean {\n    let isValid = true;\n    let hasMatch = false;\n    const t = transition;\n    const { name, type } = rule;\n    const strRule = name as IRules['strings'];\n    const objRule = name as IRules['object'];\n    const fnName = name as IRules['function'];\n    const base = direction ? t[direction] : t; // = t || t.from || t.to\n    const page = direction === 'to' ? data.next : data.current; // = current || next\n    const exist = direction ? base && base[name] : base[name];\n\n    // If transition rule exists\n    if (exist) {\n      switch (type) {\n        case 'strings':\n        default: {\n          // Array support\n          const names: string[] = Array.isArray(base[strRule])\n            ? (base[strRule] as string[])\n            : [base[strRule] as string];\n\n          // For matching, prop should be present on both sides and match\n          if (page[strRule] && names.indexOf(page[strRule]) !== -1) {\n            hasMatch = true;\n          }\n          // If transition prop is different from current, not valid\n          if (names.indexOf(page[strRule]) === -1) {\n            isValid = false;\n          }\n          break;\n        }\n\n        case 'object': {\n          // Array support\n          const names: string[] = Array.isArray(base[objRule])\n            ? (base[objRule] as string[])\n            : [base[objRule] as string];\n\n          // For matching, prop should be present on both sides and match\n          if (page[objRule]) {\n            if (\n              page[objRule].name &&\n              names.indexOf(page[objRule].name) !== -1\n            ) {\n              hasMatch = true;\n            }\n            // If transition prop is different from current, not valid\n            if (names.indexOf(page[objRule].name) === -1) {\n              isValid = false;\n            }\n          } else {\n            isValid = false;\n          }\n          break;\n        }\n\n        case 'function':\n          if (base[fnName](data)) {\n            hasMatch = true;\n          } else {\n            isValid = false;\n          }\n          break;\n      }\n\n      if (hasMatch) {\n        if (direction) {\n          match[direction] = match[direction] || {};\n          match[direction][name] = t[direction][name];\n        } else {\n          match[name] = t[name];\n        }\n      }\n    }\n\n    return isValid;\n  }\n\n  /**\n   * ### Calculate transition priority.\n   *\n   * Based on:\n   *\n   * - rule \"position\" (index) give tens, hundreds, thousands, \n   * - from/to properties give units (0, 1 or 2)\n   */\n  private _calculatePriority(\n    t: ITransitionPage,\n    ruleName: RuleName,\n    ruleIndex: number\n  ): number {\n    let priority = 0;\n\n    if (\n      t[ruleName] ||\n      (t.from && t.from[ruleName]) ||\n      (t.to && t.to[ruleName])\n    ) {\n      priority += Math.pow(10, ruleIndex);\n\n      if (t.from && t.from[ruleName]) {\n        priority += 1;\n      }\n      if (t.to && t.to[ruleName]) {\n        priority += 2;\n      }\n    }\n\n    return priority;\n  }\n\n  private _addPriority(t: ITransitionPage): ITransitionPage {\n    t.priority = 0;\n    let priority = 0;\n\n    this._rules.forEach((rule, i) => {\n      const { name } = rule;\n      const index = i + 1;\n\n      priority += this._calculatePriority(t, name, index);\n    });\n\n    t.priority = priority;\n\n    return t;\n  }\n}\n","/**\n * @barba/core/modules/transitions\n * <br><br>\n * ## Transitions manager.\n *\n * - Handle hooks and transition lifecycle\n *\n * @module core/modules/transitions\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport {\n  HooksTransition,\n  HooksTransitionMap,\n  ITransitionData,\n  ITransitionFilters,\n  ITransitionOnce,\n  ITransitionPage,\n  Wrapper,\n} from '../defs';\n// Hooks\nimport { hooks } from '../hooks';\n// Utils\nimport { dom, helpers, runAsync } from '../utils';\n// Modules\nimport { BarbaError } from './Error';\nimport { Logger } from './Logger';\nimport { Store } from './Store';\n\nexport class Transitions {\n  public logger: Logger = new Logger('@barba/core');\n  public store: Store;\n  private _running: boolean = false;\n\n  constructor(transitions: ITransitionPage[] = []) {\n    this.store = new Store(transitions);\n  }\n\n  /**\n   * Get resolved transition\n   *\n   * - based on data\n   */\n  public get(\n    data: ITransitionData,\n    filters?: ITransitionFilters\n  ): ITransitionOnce | ITransitionPage {\n    return this.store.resolve(data, filters);\n  }\n\n  /**\n   * Animation running status.\n   */\n  get isRunning(): boolean {\n    return this._running;\n  }\n  set isRunning(status: boolean) {\n    this._running = status;\n  }\n\n  /**\n   * Check for registered once transition(s).\n   */\n  get hasOnce(): boolean {\n    return this.store.once.length > 0;\n  }\n\n  /**\n   * Check for registered self transition.\n   */\n  get hasSelf(): boolean {\n    return this.store.all.some(t => t.name === 'self');\n  }\n\n  /**\n   * ### Wait indicator.\n   *\n   * Tells Barba to get next page data<br>\n   * before starting the resolution<br>\n   * because some registered transitions need<br>\n   * next page data to be resolved (eg: `sync: true`, `to: { namespace }`, )\n   */\n  get shouldWait(): boolean {\n    return this.store.all.some(t => (t.to && !t.to.route) || t.sync);\n  }\n\n  /**\n   * ### Do \"once\" transition.\n   *\n   * Hooks: see [[HooksOnce]].\n   */\n  public async doOnce({\n    data,\n    transition,\n  }: {\n    data: ITransitionData;\n    transition: ITransitionOnce;\n  }) {\n    const t = transition || {};\n    this._running = true;\n\n    try {\n      await this._doAsyncHook('beforeOnce', data, t);\n      await this.once(data, t);\n      await this._doAsyncHook('afterOnce', data, t);\n    } catch (error) {\n      this._running = false;\n\n      this.logger.debug('Transition error [before/after/once]');\n      this.logger.error(error);\n    }\n\n    this._running = false;\n  }\n\n  /**\n   * ### Do \"page\" transition.\n   *\n   * Hooks: see [[HooksPage]].\n   *\n   * `sync: false` (default) order:\n   *\n   * 1. before\n   * 2. beforeLeave\n   * 3. leave\n   * 4. afterLeave\n   * 5. beforeEnter\n   * 6. enter\n   * 7. afterEnter\n   * 8. after\n   *\n   * `sync: true` order:\n   *\n   * 1. before\n   * 2. beforeLeave\n   * 3. beforeEnter\n   * 4. leave & enter\n   * 5. afterLeave\n   * 6. afterEnter\n   * 7. after\n   */\n  public async doPage({\n    data,\n    transition,\n    page,\n    wrapper,\n  }: {\n    data: ITransitionData;\n    transition: ITransitionPage;\n    page: Promise<string | void>;\n    wrapper: Wrapper;\n  }) {\n    const t = transition || {};\n    const sync = t.sync === true || false;\n\n    this._running = true;\n\n    try {\n      // Check sync mode, wait for next content\n      if (sync) {\n        await helpers.update(page, data);\n      }\n\n      await this._doAsyncHook('before', data, t);\n\n      if (sync) {\n        try {\n          await this.add(data, wrapper);\n          // Before actions\n          await this._doAsyncHook('beforeLeave', data, t);\n          await this._doAsyncHook('beforeEnter', data, t);\n\n          // Actions\n          await Promise.all([this.leave(data, t), this.enter(data, t)]);\n\n          // After actions\n          await this._doAsyncHook('afterLeave', data, t);\n          await this._doAsyncHook('afterEnter', data, t);\n        } catch (error) {\n          // this.logger.debug('Transition error [sync]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(error, 'Transition error [sync]');\n          }\n        }\n      } else {\n        let leaveResult: any = false;\n\n        try {\n          // Leave\n          await this._doAsyncHook('beforeLeave', data, t);\n\n          leaveResult = await Promise.all([\n            this.leave(data, t),\n            helpers.update(page, data),\n          ]).then(values => values[0]);\n\n          await this._doAsyncHook('afterLeave', data, t);\n\n          // TODO: check here \"valid\" page result\n          // before going further\n        } catch (error) {\n          // this.logger.debug('Transition error [before/after/leave]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(\n              error,\n              'Transition error [before/after/leave]'\n            );\n          }\n        }\n\n        try {\n          // Enter\n          /* istanbul ignore else */\n          if (leaveResult !== false) {\n            await this.add(data, wrapper);\n\n            await this._doAsyncHook('beforeEnter', data, t);\n            await this.enter(data, t, leaveResult);\n            await this._doAsyncHook('afterEnter', data, t);\n          }\n        } catch (error) {\n          // this.logger.debug('Transition error [before/after/enter]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(\n              error,\n              'Transition error [before/after/enter]'\n            );\n          }\n        }\n      }\n\n      // Remove current contaienr\n      await this.remove(data);\n\n      await this._doAsyncHook('after', data, t);\n    } catch (error) {\n      this._running = false;\n\n      // If \"custom/specific\" barba error.\n      /* istanbul ignore else */\n      if (error.name && error.name === 'BarbaError') {\n        this.logger.debug(error.label);\n        this.logger.error(error.error);\n\n        throw error;\n      }\n\n      this.logger.debug('Transition error [page]');\n      this.logger.error(error);\n\n      throw error;\n    }\n\n    this._running = false;\n  }\n\n  /**\n   * Once hook + async \"once\" transition.\n   */\n  public async once(data: ITransitionData, t: ITransitionOnce): Promise<void> {\n    await hooks.do('once', data, t);\n\n    return t.once ? runAsync(t.once, t)(data) : Promise.resolve();\n  }\n\n  /**\n   * Leave hook + async \"leave\" transition.\n   */\n  public async leave(data: ITransitionData, t: ITransitionPage): Promise<any> {\n    await hooks.do('leave', data, t);\n\n    return t.leave ? runAsync(t.leave, t)(data) : Promise.resolve();\n  }\n\n  /**\n   * Enter hook + async \"enter\" transition.\n   */\n  public async enter(\n    data: ITransitionData,\n    t: ITransitionPage,\n    leaveResult?: any\n  ): Promise<void> {\n    await hooks.do('enter', data, t);\n\n    return t.enter\n      ? runAsync(t.enter, t)(data, leaveResult)\n      : Promise.resolve();\n  }\n\n  /**\n   * Add next container.\n   */\n  public async add(data: ITransitionData, wrapper: Wrapper): Promise<void> {\n    dom.addContainer(data.next.container, wrapper);\n    hooks.do('nextAdded', data);\n  }\n\n  /**\n   * Remove current container.\n   */\n  public async remove(data: ITransitionData): Promise<void> {\n    dom.removeContainer(data.current.container);\n    hooks.do('currentRemoved', data);\n  }\n\n  private _isTransitionError(error: any) {\n    if (error.message) {\n      // Errors from request\n      return !/Timeout error|Fetch error/.test(error.message);\n    }\n\n    if (error.status) {\n      // Errors from request\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Do hooks + async transition methods.\n   */\n  private async _doAsyncHook(\n    hook: HooksTransition,\n    data: ITransitionData,\n    t: HooksTransitionMap\n  ): Promise<void> {\n    await hooks.do(hook, data, t);\n\n    return t[hook] ? runAsync(t[hook], t)(data) : Promise.resolve();\n  }\n}\n","/**\n * @barba/core/modules/views\n * <br><br>\n * ## Views manager.\n *\n * @module core/modules/views\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HooksView, IView, IViewData } from '../defs';\n// Hooks\nimport { hooks } from '../hooks';\n// Utils\nimport { runAsync } from '../utils';\n// Types\ntype Hook = (data: IViewData) => Promise<void>;\n\nexport class Views {\n  /**\n   * Available hook names for views.\n   */\n  public names: HooksView[] = [\n    'beforeLeave',\n    'afterLeave',\n    'beforeEnter',\n    'afterEnter',\n  ];\n  /**\n   * Registered views by namespace.\n   */\n  public byNamespace: Map<string, IView> = new Map();\n\n  /**\n   * Init views.\n   */\n  constructor(views: IView[]) {\n    if (views.length === 0) {\n      return;\n    }\n\n    // TODO: add check\n    // for valid views? criteria? (namespace property, string ?)\n    // or duplicate\n    views.forEach(view => {\n      this.byNamespace.set(view.namespace, view);\n    });\n\n    this.names.forEach(name => {\n      hooks[name](this._createHook(name));\n    });\n  }\n\n  /**\n   * Create the hook method.\n   *\n   * - get view based on namespace\n   * - execute callback with transition data\n   */\n  private _createHook(name: HooksView): Hook {\n    return data => {\n      const { namespace } = name.match(/enter/i) ? data.next : data.current;\n      const view = this.byNamespace.get(namespace);\n\n      // TODO: manage self\n      // if (view && data.trigger !== 'self') {\n      if (view && view[name]) {\n        return runAsync(view[name], view)(data);\n      }\n\n      return Promise.resolve();\n    };\n  }\n}\n","// Element.prototype.matches polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    (Element as any).prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n}\n\n// Element.prototype.closest polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function closest(s: string) {\n    let el = this;\n\n    do {\n      if (el.matches(s)) {\n        return el;\n      }\n\n      el = (el.parentElement || el.parentNode) as Element;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  };\n}\n","/**\n * @module core/schemas\n */\n\n// Definitions\nimport { ISchemaPage } from '../defs';\n\n/**\n * See [[ISchemaPage]]\n */\nexport const schemaPage: ISchemaPage = {\n  container: null,\n  html: '',\n  namespace: '',\n  url: {\n    hash: '',\n    href: '',\n    path: '',\n    port: null,\n    query: {},\n  },\n};\n","/**\n * @barba/css\n * <br><br>\n * ## Barba CSS.\n *\n * - Add CSS classes\n * - Manage CSS transitions\n *\n * @module css\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport {\n  IBarbaPlugin,\n  ITransitionData,\n  ITransitionPage,\n} from '@barba/core/src/defs';\n\nimport { Core } from '@barba/core/src/core';\nimport { Logger } from '@barba/core/src/modules/Logger';\n\nimport { ICssCallbacks } from './defs';\n\nimport { version } from '../package.json';\n\nexport class Css implements IBarbaPlugin<{}> {\n  public name = '@barba/css';\n  public version = version;\n  public barba: Core;\n  public logger: Logger;\n\n  public prefix: string = 'barba';\n  public callbacks: ICssCallbacks = {};\n  public cb: any;\n\n  // Check if transition property applied\n  private _hasTransition: boolean = false;\n\n  /**\n   * Plugin installation.\n   */\n  public install(barba: Core) {\n    this.logger = new barba.Logger(this.name);\n    this.logger.info(this.version);\n    this.barba = barba;\n    this._once = this._once.bind(this);\n    this._leave = this._leave.bind(this);\n    this._enter = this._enter.bind(this);\n  }\n\n  /**\n   * Plugin installation.\n   */\n  public init() {\n    // Register hooks to get prefix\n    this.barba.hooks.before(this._getPrefix, this);\n    this.barba.hooks.beforeOnce(this._getPrefix, this);\n\n    // Register hook for CSS classes\n    this.barba.hooks.beforeOnce(this._beforeOnce, this);\n    this.barba.hooks.afterOnce(this._afterOnce, this);\n    this.barba.hooks.beforeLeave(this._beforeLeave, this);\n    this.barba.hooks.afterLeave(this._afterLeave, this);\n    this.barba.hooks.beforeEnter(this._beforeEnter, this);\n    this.barba.hooks.afterEnter(this._afterEnter, this);\n\n    // Override main transitions\n    this.barba.transitions.once = this._once;\n    this.barba.transitions.leave = this._leave;\n    this.barba.transitions.enter = this._enter;\n\n    // Add empty default transition (force prepend)\n    /* istanbul ignore next */\n    this.barba.transitions.store.all.unshift({\n      name: 'barba',\n      once() {}, // tslint:disable-line:no-empty\n      leave() {}, // tslint:disable-line:no-empty\n      enter() {}, // tslint:disable-line:no-empty\n    });\n    this.barba.transitions.store.update();\n  }\n\n  /**\n   * Initial state.\n   */\n  public async start(container: HTMLElement, kind: string): Promise<void> {\n    // Set initial CSS values\n    this.add(container, kind); // CSS: add kind\n    await this.barba.helpers.nextTick();\n    // Apply CSS transition\n    this.add(container, `${kind}-active`); // CSS: add kind-active\n    await this.barba.helpers.nextTick();\n  }\n\n  /**\n   * Next frame state.\n   */\n  public async next(container: HTMLElement, kind: string): Promise<any> {\n    this._hasTransition = this._checkTransition(container);\n\n    if (this._hasTransition) {\n      // We need to listen the end of the animation\n      return new Promise(async resolve => {\n        this.cb = resolve;\n        this.callbacks[kind] = resolve;\n\n        container.addEventListener('transitionend', resolve, false);\n        await this.barba.helpers.nextTick();\n        this.remove(container, kind); // CSS: remove kind\n        // await this.barba.helpers.nextTick();\n        this.add(container, `${kind}-to`); // CSS: add kind-to\n        await this.barba.helpers.nextTick();\n      });\n    } else {\n      this.remove(container, kind); // CSS: remove kind\n      await this.barba.helpers.nextTick();\n      this.add(container, `${kind}-to`); // CSS: add kind-to\n      await this.barba.helpers.nextTick();\n    }\n  }\n\n  /**\n   * Final state.\n   */\n  public async end(container: HTMLElement, kind: string): Promise<void> {\n    this.remove(container, `${kind}-to`); // CSS: remove kind-to\n    this.remove(container, `${kind}-active`); // CSS: remove kind-active\n    container.removeEventListener('transitionend', this.callbacks[kind]);\n    this._hasTransition = false;\n  }\n\n  /**\n   * Add CSS classes.\n   */\n  public add(el: HTMLElement, step: string): void {\n    el.classList.add(`${this.prefix}-${step}`);\n  }\n\n  /**\n   * Remove CSS classes.\n   */\n  public remove(el: HTMLElement, step: string): void {\n    el.classList.remove(`${this.prefix}-${step}`);\n  }\n\n  /**\n   * Get CSS prefix from transition `name` property.\n   */\n  private _getPrefix(data: ITransitionData, t: ITransitionPage): void {\n    this.prefix = t.name || 'barba';\n  }\n\n  /**\n   * Check if CSS transition is applied\n   */\n  private _checkTransition(container: HTMLElement) {\n    // DEV: check for CSS animation property?\n    return getComputedStyle(container).transitionDuration !== '0s';\n  }\n\n  /**\n   * `beforeOnce` hook.\n   */\n  private _beforeOnce(data: ITransitionData): Promise<void> {\n    return this.start(data.next.container, 'once');\n  }\n\n  /**\n   * `once` hook.\n   */\n  private async _once(data: ITransitionData, t: ITransitionPage): Promise<any> {\n    await this.barba.hooks.do('once', data, t);\n\n    return this.next(data.next.container, 'once');\n  }\n\n  /**\n   * `afterOnce` hook.\n   */\n  private _afterOnce(data: ITransitionData): Promise<void> {\n    return this.end(data.next.container, 'once');\n  }\n\n  /**\n   * `beforeLeave` hook.\n   */\n  private _beforeLeave(data: ITransitionData): Promise<void> {\n    return this.start(data.current.container, 'leave');\n  }\n\n  /**\n   * `leave` hook.\n   */\n  private async _leave(\n    data: ITransitionData,\n    t: ITransitionPage\n  ): Promise<void> {\n    await this.barba.hooks.do('leave', data, t);\n\n    return this.next(data.current.container, 'leave');\n  }\n\n  /**\n   * `afterLeave` hook.\n   */\n  private _afterLeave(data: ITransitionData): Promise<void> {\n    this.end(data.current.container, 'leave');\n    // For CSS transitions, we need to remove current container\n    // directly after the leave transition\n    this.barba.transitions.remove(data);\n\n    return Promise.resolve();\n  }\n\n  /**\n   * `beforeEnter` hook.\n   */\n  private _beforeEnter(data: ITransitionData): Promise<void> {\n    // Avoid on first load\n    if (this.barba.history.size === 1) {\n      return Promise.resolve();\n    }\n    return this.start(data.next.container, 'enter');\n  }\n\n  /**\n   * `enter` hook.\n   */\n  private async _enter(\n    data: ITransitionData,\n    t: ITransitionPage\n  ): Promise<void> {\n    await this.barba.hooks.do('enter', data, t);\n\n    return this.next(data.next.container, 'enter');\n  }\n\n  /**\n   * `afterEnter` hook.\n   */\n  private _afterEnter(data: ITransitionData): Promise<void> {\n    // Avoid on first load\n    if (this.barba.history.size === 1) {\n      return Promise.resolve();\n    }\n    return this.end(data.next.container, 'enter');\n  }\n}\n\nconst css = new Css();\n\nexport default css;\n"]}